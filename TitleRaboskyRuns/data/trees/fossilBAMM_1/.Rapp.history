edgeWeights
edgeIndices
lambdaTree$edge.length[edgeIndices]
edgeWeights
muTree$edge.length[edgeIndices]
# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.lambda)) {#
		edgeIndices <- root2tipEdges(tr, sp = regimeTips[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}
j
# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}
tipTable
j<-1
regimeTips <- tips(tr, modelDat[j, 'regimeMRCA'])
regimeTips
subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])
subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])
subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])
subClade
subLambda
subMu
k<-1
modelDat
subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])
edgeIndices <- root2tipEdges(tr, sp = subClade$tip.label[k])
k
edgeIndices
plot(subClade)
maxBT <- max(NU.branching.times(subClade))
edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])
edgeIndices
edgeWeights <- subClade$edge.length[edgeIndices] / maxBT
edgeWeights
subClade$tip.label[k]
# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[subClade$tip.label[k], 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[subClade$tip.label[k], 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}
head(tipTable)
j<-1
k<-1
subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))
maxBT
modelDat
k
edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])
edgeWeights <- subClade$edge.length[edgeIndices] / maxBT
which(tipTable$tipName == subClade$tip.label[k])
subClade$tip.label[k]
for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}
head(tipTable)
# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}
head(tipTable)
cat(i, 'of', length(treeInd), '\n')
unique(treeDat$setname)
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates')), 'treeName'])
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])
treeInd
io<-1
i<-1
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])
cat(i, 'of', length(treeInd), '\n')
modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat
modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]
tr
plot(tr)
names(tr)
trPruned <- drop.extinct(tr)
tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = 9))
colnames(tipTable) <- c('treeName','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')
tipTable[, 'treeName'] <- treeInd[i]
tipTable[, 'tipName'] <- trPruned$tip.label
tipTable[, 'regimeID'] <- 'regime1'
head(tipTable)
eps <- modelDat$mu0 / modelDat$lambda0
eps
tr$mu <- tr$lambda * eps
tipTable$tipLambda <- getTerminalLambda(tr)
tipTable$tipMu <- getTerminalMu(tr)
j<-1
edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])
edgeIndices
edgeWeights <- tr$edge.length[edgeIndices] / max(NU.branching.times(tr))
max(NU.branching.times(tr))
maxBT <- max(NU.branching.times(tr))
edgeWeights <- tr$edge.length[edgeIndices] / maxBT
edgeWeights
maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}
tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']
head(tipTable)
tail(tipTable)
i<-300
i<-500
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat
# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = 9))#
	colnames(tipTable) <- c('treeName','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']
head(tipTablw)
head(tipTable)
tail(tipTable)
unique(treeDat$setname)
basepath <- '~/Documents/UmichDocs/MEA_response_BAMM/'#
destinationpath <- '~/Dropbox/tipRatesProject/'#
#
require(ape)#
#
writeFiles <- FALSE#
#
masterFile <- '~/Dropbox/tipRatesProject/treeSummary.csv'#
#
masterTable <- read.csv(masterFile, stringsAsFactors=FALSE)#
#
summaryTable <- as.data.frame(matrix(nrow = 0, ncol = ncol(masterTable)))#
colnames(summaryTable) <- colnames(masterTable)
#------------------------------------------------#
## Moore et al. 2016 100x rate-variable trees#
## - BAMM analyses performed in Rabosky et al. 2017#
#
# table of simulation values#
truedat <- read.csv(paste0(destinationpath, 'simulationRefs/RaboskyMitchellChang2017/Figure_9-12/regimesSummary.csv'), stringsAsFactors=FALSE)#
truedat <- truedat[which(truedat$prior == 1.0),]#
#
# label#
setname <- 'MooreEtAl2016'#
#
tmpTable <- as.data.frame(matrix(nrow = nrow(truedat), ncol = ncol(summaryTable)))#
colnames(tmpTable) <- colnames(summaryTable)#
tmpTable$source <- 'Moore et al. 2016'#
tmpTable$description <- 'multi-regime, rate-constant birth-death'#
tmpTable$processType <- 'birth-death'#
tmpTable$treeName <- paste0(setname, '_', truedat$tree)#
tmpTable$regimeMRCA <- truedat$node#
tmpTable$regimeTime <- truedat$time#
tmpTable$regime_nTips <- truedat$N_taxa#
tmpTable$lambda0 <- truedat$true_lambda#
tmpTable$mu0 <- truedat$true_mu#
tmpTable$lambda1 <- 0#
tmpTable$mu1 <- 0#
tmpTable$setname <- setname
for (i in 1:100) {#
	tr <- read.tree(paste0(basepath, 'mea_trees_recompute/simulation_study/variable_rates/tree_', i, '/sim_', i, '.tre'))#
	tmpTable[which(tmpTable$treeName == paste0(setname, '_', i)), 'nTips_all'] <- length(tr$tip.label)#
	# locate and move tree as well as BAMM files#
	if (writeFiles) {#
		path <- paste0(destinationpath, 'trees/', setname, '_', i)#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(tr, paste0(path, '/', setname, '_', i, '.tre'))#
		# move BAMM results files#
		files <- list.files(paste0(basepath, 'mea_trees_recompute/simulation_study/variable_rates/tree_', i, '/gamma_1/run_1'), pattern = 'autoprior_sans_bad_extinction', full.names=TRUE)#
		sapply(files, function(x) file.copy(from = x, to = paste0(path, '/', basename(x))))	#
	}#
}#
#
summaryTable <- rbind.data.frame(summaryTable, tmpTable, stringsAsFactors=FALSE)
#------------------------------------------------#
## Rabosky, Mitchell and Chang 2017 400x rate-variable trees#
## - BAMM analyses performed in Rabosky et al. 2017#
#
# We will assign these analyses 1:200 lambda_0.01 and 201:400 lambda_0.001#
#
## lambda_0.01#
#
# table of simulation values#
truedat <- read.csv(paste0(basepath, 'lambda_0-01/input/v2.5_regimesSummary.csv'), stringsAsFactors=FALSE)#
truedat <- truedat[which(truedat$prior == 'p1'),]#
#
# label#
setname <- 'RaboskyEtAl2017'#
#
tmpTable <- as.data.frame(matrix(nrow = nrow(truedat), ncol = ncol(summaryTable)))#
colnames(tmpTable) <- colnames(summaryTable)#
tmpTable$source <- 'Rabosky et al. 2017'#
tmpTable$description <- 'multi-regime, rate-constant birth-death'#
tmpTable$processType <- 'birth-death'#
tmpTable$treeName <- paste0(setname, '_', truedat$analysis_number)#
tmpTable$regimeMRCA <- truedat$node#
tmpTable$regimeTime <- truedat$time#
tmpTable$regime_nTips <- truedat$N_taxa#
tmpTable$lambda0 <- truedat$true_lambda#
tmpTable$mu0 <- truedat$true_mu#
tmpTable$setname <- setname#
tmpTable$lambda1 <- 0#
tmpTable$mu1 <- 0#
for (i in 1:200) {#
	tr <- read.tree(paste0(basepath, 'lambda_0-01/output/sim-', i, '/exPhy.tre'))#
	tmpTable[which(tmpTable$treeName == paste0(setname, '_', i)), 'nTips_all'] <- length(tr$tip.label)#
	# locate and move tree as well as BAMM files#
	if (writeFiles) {#
		path <- paste0(destinationpath, 'trees/', setname, '_', i)#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(tr, paste0(path, '/', setname, '_', i, '.tre'))#
		# move BAMM results files#
		files <- list.files(paste0(basepath, 'lambda_0-01/output/sim-', i), pattern = 'v2.5_k01', full.names=TRUE)#
		sapply(files, function(x) file.copy(from = x, to = paste0(path, '/', basename(x))))	#
	}#
}#
#
summaryTable <- rbind.data.frame(summaryTable, tmpTable, stringsAsFactors=FALSE)#
## lambda_0.001#
#
# table of simulation values#
truedat <- read.csv(paste0(basepath, 'lambda_0-001/input/v2.5_regimesSummary.csv'), stringsAsFactors=FALSE)#
truedat <- truedat[which(truedat$prior == 'p1'),]#
#
# label#
setname <- 'RaboskyEtAl2017'#
#
tmpTable <- as.data.frame(matrix(nrow = nrow(truedat), ncol = ncol(summaryTable)))#
colnames(tmpTable) <- colnames(summaryTable)#
tmpTable$source <- 'Rabosky et al. 2017'#
tmpTable$description <- 'multi-regime, rate-constant birth-death'#
tmpTable$processType <- 'birth-death'#
tmpTable$treeName <- paste0(setname, '_', truedat$analysis_number + 200)#
tmpTable$regimeMRCA <- truedat$node#
tmpTable$regimeTime <- truedat$time#
tmpTable$regime_nTips <- truedat$N_taxa#
tmpTable$lambda0 <- truedat$true_lambda#
tmpTable$mu0 <- truedat$true_mu#
tmpTable$setname <- setname#
tmpTable$lambda1 <- 0#
tmpTable$mu1 <- 0#
for (i in 1:200) {#
	tr <- read.tree(paste0(basepath, 'lambda_0-001/output/sim-', i, '/exPhy.tre'))#
	tmpTable[which(tmpTable$treeName == paste0(setname, '_', i + 200)), 'nTips_all'] <- length(tr$tip.label)#
	# locate and move tree as well as BAMM files#
	if (writeFiles) {#
		path <- paste0(destinationpath, 'trees/', setname, '_', i + 200)#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(tr, paste0(path, '/', setname, '_', i + 200, '.tre'))#
		# move BAMM results files#
		files <- list.files(paste0(basepath, 'lambda_0-001/output/sim-', i), pattern = 'v2.5_k01', full.names=TRUE)#
		sapply(files, function(x) file.copy(from = x, to = paste0(path, '/', basename(x))))	#
	}#
}
summaryTable <- rbind.data.frame(summaryTable, tmpTable, stringsAsFactors=FALSE)
masterTable <- rbind.data.frame(masterTable, summaryTable, stringsAsFactors=FALSE)
write.csv(masterTable, masterFile, row.names = FALSE)
# For each simulated phylogeny, calculate the following metrics based on true simulation parameters:#
#- true lambda at tip#
#- true mu at tip#
#- true mean lambda of path from regime start to tip#
#- true mean mu of path from regime start to tip#
#- true mean lambda of path from root to tip#
#- true mean mu of path from root to tip#
# also track:#
#- tree name#
#- tip name#
#- regime tip belongs to#
#
basepath <- '~/Dropbox/tipRatesProject/trees/'#
#
# tree summary file#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
require(ape)#
require(geiger)#
#
source('~/Dropbox/tipRatesProject/sourceFxns.R')#
#
evolvingRates_trees_alltips <- readRDS('~/Dropbox/tipRatesProject/simulations/evolvingRates/evolvingRates_trees_alltips.rds')#
trueTipDat <- vector('list', length = length(unique(treeDat$treeName)))#
names(trueTipDat) <- unique(treeDat$treeName)
unique(treeDat$setname)
treeInd <- unique(treeDat[which(treeDat$setname %in% c('MitchellRabosky2016', 'MeyerWiens2017', 'MooreEtAl2016', 'RaboskyEtAl2017', 'highTurnoverBD', 'LambdaEqualsMu', 'fossilBAMM')), 'treeName'])
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = 10))#
	colnames(tipTable) <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	# order ascending by regimeTime (regimeTime is time from root)#
	modelDat <- modelDat[order(modelDat$regimeTime, decreasing = FALSE),]#
	for (j in 1:nrow(modelDat)) {#
		regimeTips <- tips(tr, modelDat[j, 'regimeMRCA'])#
		tipInd <- which(tipTable$tipName %in% regimeTips)#
		tipTable[tipInd, 'regimeID'] <- paste0('regime', j)#
		tipTable[tipInd, c('tipLambda', 'tipMu')] <- modelDat[j, c('lambda0', 'mu0')]#
	}#
	# path metrics#
	pathMetrics <- calcMeanPath(tr, modelDat)#
	tipTable[, 'regimePathLambda'] <- pathMetrics$regime2tipLambda#
	tipTable[, 'regimePathMu'] <- pathMetrics$regime2tipMu#
	tipTable[, 'root2tipLambda'] <- pathMetrics$root2tipLambda#
	tipTable[, 'root2tipMu'] <- pathMetrics$root2tipMu#
	trueTipDat[[treeInd[i]]] <- tipTable#
#
}
head(trueTipDat)
tail(trueTipDat)
tail(treeInd)
length(treeInd)
treeInd
trueTipDat['fossilBAMM_79']
# --------------------------------------#
## diversity-dependent models#
treeInd <- unique(treeDat[which(treeDat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')), 'treeName'])#
#
# for these models, we will use the lambda and mu trees supplied in Rabosky 2014.#
# in these trees, branches have been scaled by their mean lambda and mu#
#
# tip rates will be terminal edge lambda and mu#
# for mean path rates, #
# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
#
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = 10))#
	colnames(tipTable) <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
i
treeInd[i]
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d', '\\1', treeInd[i])
nShifts
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])
nShifts
treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))
treeNum
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = 10))#
	colnames(tipTable) <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
# --------------------------------------#
## evolving rates model#
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])#
#
# for these models, we will use branch-specific lambda and mu.#
#
# tip rates will be terminal edge lambda and mu#
# path rates will be the weighted mean path rates, where weights are branch lengths from time tree#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = 9))#
	colnames(tipTable) <- c('treeName','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
trueTipRates <- do.call(rbind, trueTipDat)
head(trueTipDat)
which(sapply(trueTipDat, is.null) == FALSE) -> zz
head(zz)
trueTipDat <- trueTipDat[zz]
trueTipRates <- do.call(rbind, trueTipDat)
i<-1
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(colnames(tipTable) <- tipTableColumns)))#
	colnames(tipTable) <- colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)
tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(colnames(tipTable) <- tipTableColumns)))#
	colnames(tipTable) <- colnames(tipTable) <- tipTableColumns
colnames(tipTable) <- tipTableColumns
tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(colnames(tipTable) <- tipTableColumns)))
tipTableColumns <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(colnames(tipTable) <- tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns
tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']
head(tipTable)
modelDat
tipTable, 'setname'] <- modelDat[1, 'setname']
tipTable[, 'setname'] <- modelDat[1, 'setname']
head(tipTable)
trueTipDat <- vector('list', length = length(unique(treeDat$treeName)))#
names(trueTipDat) <- unique(treeDat$treeName)
tipTableColumns <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')#
#
# --------------------------------------#
## pure-birth and birth-death models#
treeInd <- unique(treeDat[which(treeDat$setname %in% c('MitchellRabosky2016', 'MeyerWiens2017', 'MooreEtAl2016', 'RaboskyEtAl2017', 'highTurnoverBD', 'LambdaEqualsMu', 'fossilBAMM')), 'treeName'])#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	# order ascending by regimeTime (regimeTime is time from root)#
	modelDat <- modelDat[order(modelDat$regimeTime, decreasing = FALSE),]#
	for (j in 1:nrow(modelDat)) {#
		regimeTips <- tips(tr, modelDat[j, 'regimeMRCA'])#
		tipInd <- which(tipTable$tipName %in% regimeTips)#
		tipTable[tipInd, 'regimeID'] <- paste0('regime', j)#
		tipTable[tipInd, c('tipLambda', 'tipMu')] <- modelDat[j, c('lambda0', 'mu0')]#
	}#
	# path metrics#
	pathMetrics <- calcMeanPath(tr, modelDat)#
	tipTable[, 'regimePathLambda'] <- pathMetrics$regime2tipLambda#
	tipTable[, 'regimePathMu'] <- pathMetrics$regime2tipMu#
	tipTable[, 'root2tipLambda'] <- pathMetrics$root2tipLambda#
	tipTable[, 'root2tipMu'] <- pathMetrics$root2tipMu#
	trueTipDat[[treeInd[i]]] <- tipTable#
#
}
# --------------------------------------#
## diversity-dependent models#
treeInd <- unique(treeDat[which(treeDat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')), 'treeName'])#
#
# for these models, we will use the lambda and mu trees supplied in Rabosky 2014.#
# in these trees, branches have been scaled by their mean lambda and mu#
#
# tip rates will be terminal edge lambda and mu#
# for mean path rates, #
# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
#
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
head(treeInd)
treeInd <- sample(treeInd, 25)
treeInd
# for these models, we will use the lambda and mu trees supplied in Rabosky 2014.#
# in these trees, branches have been scaled by their mean lambda and mu#
#
# tip rates will be terminal edge lambda and mu#
# for mean path rates, #
# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
#
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d)', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
i
treeInd[i]
cat(i, 'of', length(treeInd), '\n')
modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?', '\\1', treeInd[i])
nShifts
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d\\d?\\d?\\d?', '\\1', treeInd[i])
nShifts
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])
nShifts
treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))
treeNum
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'#
#
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
#
		subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
		subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
		subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
		maxBT <- max(NU.branching.times(subClade))#
		tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
		for (k in 1:length(subClade$tip.label)) {#
			edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
			edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
		}#
	}#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
i
treeInd[i]
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])
treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))
nShifts
treeNum
i<-10
treeInd[i]
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])
treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))
nShifts
treeNum
i<-8
treeInd[i]
nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])
treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))
nShifts
treeNum
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])
treeInd <- sample(treeInd, 25)
treeInd
for (i in 1:length(treeInd)) {#
	cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1, 'setname']#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']#
	trueTipDat[[treeInd[i]]] <- tipTable#
}
trueTipDat <- trueTipDat[which(sapply(trueTipDat, is.null) == F)]
head(trueTipDat)
trueTipRates <- do.call(rbind, trueTipDat)
outfile <- '~/Dropbox/tipRatesProject/trueTipRates.csv'
head(trueTipRates)
write.csv(trueTipRates, outfile, row.names=FALSE)
# Infer tip rates#
#- with BAMM#
#- DR stat#
#- node density#
#- inverse terminal branch length#
#- constant-rate-birth-death#
#
basepath <- '~/Dropbox/tipRatesProject/trees/'#
treefolders <- list.files(basepath)#
#
require(ape)#
require(geiger)#
require(BAMMtools)
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')
tipTableColumns <- c('treeName','setname','tipName','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
estimRatesList <- vector('list', length(treefolders))#
names(estimRatesList) <- treefolders
i<-1
setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable$treeName <- treefolders[i]#
	tipTable$setname <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	tipTable$tipName <- tr$tip.label
# inverse terminal branch lengths#
	tipTable$lambdaTB <- inverseTerminalBranches(tr)#
	# node density#
	tipTable$lambdaND <- nodeDensity(tr)#
	# DR#
	tipTable$lambdaDR <- DRstat(tr)
# BAMM results can either be in the form of BAMM data files, or as a file containing tip rates#
	if (any(grepl('event_data.txt', files))) {#
		ed <- getEventData(tr, grep('event_data.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
		tipTable$lambdaBAMM <- ed$meanTipLambda#
	} else if ('tiprates.csv' %in% files) {#
		tipTable$lambdaBAMM <- read.csv('tiprates.csv')$bammTipLambda#
	} else {#
		# BAMM files not present. log this.#
		BAMMmissing <- c(BAMMmissing, treefolders[i])#
	}
require(ape)#
require(geiger)#
require(BAMMtools)#
#
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')#
#
tipTableColumns <- c('treeName','setname','tipName','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
estimRatesList <- vector('list', length(treefolders))#
names(estimRatesList) <- treefolders#
#
BAMMmissing <- c()#
#
for (i in 1:length(treefolders)) {#
	cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable$treeName <- treefolders[i]#
	tipTable$setname <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	tipTable$tipName <- tr$tip.label#
	# inverse terminal branch lengths#
	tipTable$lambdaTB <- inverseTerminalBranches(tr)#
	# node density#
	tipTable$lambdaND <- nodeDensity(tr)#
	# DR#
	tipTable$lambdaDR <- DRstat(tr)#
	# BAMM results can either be in the form of BAMM data files, or as a file containing tip rates#
	if (any(grepl('event_data.txt', files))) {#
		ed <- getEventData(tr, grep('event_data.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
		tipTable$lambdaBAMM <- ed$meanTipLambda#
	} else if ('tiprates.csv' %in% files) {#
		tipTable$lambdaBAMM <- read.csv('tiprates.csv')$bammTipLambda#
	} else {#
		# BAMM files not present. log this.#
		BAMMmissing <- c(BAMMmissing, treefolders[i])#
	}	#
}
ind <- sample(1:3408, 50)
for (i in ind) {
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable$treeName <- treefolders[i]#
	tipTable$setname <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	tipTable$tipName <- tr$tip.label#
	# inverse terminal branch lengths#
	tipTable$lambdaTB <- inverseTerminalBranches(tr)#
	# node density#
	tipTable$lambdaND <- nodeDensity(tr)#
	# DR#
	tipTable$lambdaDR <- DRstat(tr)#
	# BAMM results can either be in the form of BAMM data files, or as a file containing tip rates#
	if (any(grepl('event_data.txt', files))) {#
		ed <- getEventData(tr, grep('event_data.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
		tipTable$lambdaBAMM <- ed$meanTipLambda#
	} else if ('tiprates.csv' %in% files) {#
		tipTable$lambdaBAMM <- read.csv('tiprates.csv')$bammTipLambda#
	} else {#
		# BAMM files not present. log this.#
		BAMMmissing <- c(BAMMmissing, treefolders[i])#
	}	#
}
i
head(tipTable)
estimRatesList[[treefolders[i]]]
estimRatesList[[treefolders[i]]] <- tipTable
estimRatesList[treefolders[i]]
outfile <- '~/Dropbox/tipRatesProject/estimatedTipRates.csv'
source('~/Dropbox/tipRatesProject/sourceFxns.R')
# estimate lambda and mu from a constant-rate birth-death process.#
crbd <- as.data.frame(matrix(nrow = length(treefolders), ncol = 4))#
colnames(crbd) <- c('treeName', 'setname', 'lambda', 'mu')
i<-1
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))
tr
fitCRBD(tr)
bdpars <- fitCRBD(tr)
bdpars
crbd[i, 'treeName'] <- treefolders[i]#
	crbd[i, 'setname'] <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	crbd[i, c('lambda', 'mu')] <- bdpars
head(crbd)
# estimate lambda and mu from a constant-rate birth-death process.#
crbd <- as.data.frame(matrix(nrow = length(treefolders), ncol = 4))#
colnames(crbd) <- c('treeName', 'setname', 'lambda', 'mu')#
#
for (i in 1:length(treefolders)) {#
	cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	bdpars <- fitCRBD(tr)#
#
	crbd[i, 'treeName'] <- treefolders[i]#
	crbd[i, 'setname'] <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	crbd[i, c('lambda', 'mu')] <- bdpars#
#
}
i
treefolders[i]
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()
files
tr <- read.tree(grep('\\.tre$', files, value = TRUE))
tr
plot(tr)
bdpars <- fitCRBD(tr)
?is.ultrametric()
is.ultrametric(tr)
is.ultrametric(tr, option=2)
phy <- tr
nopt=5
lmin=0.001
lmax=5.0
MAXBAD = 200
length(phy$tip.label) < 3
fx <- make.bd(phy)
make.bd(?make.bd)
?make.bd
require(devtools)
install_github('richfitz/diversitree')
install_github('richfitz/diversitree')
