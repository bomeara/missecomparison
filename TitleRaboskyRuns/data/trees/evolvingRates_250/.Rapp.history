mtext(sourceName[i], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
titleLines <- c(-2)#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
			heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}
mtext(sourceName[i], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)
grconvertX(0.25, "ndc", "user")
grconvertY(0.9, "ndc", "user")
segments(x0 = grconvertX(0.25, "ndc", "user") - 1, y0=grconvertY(0.9, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 1, y1 = grconvertY(0.9, "ndc", "user"))
segments(x0 = grconvertX(0.25, "ndc", "user") - 1, y0=grconvertY(0.9, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 1, y1 = grconvertY(0.9, "ndc", "user"), xpd=NA)
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.95, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.95, "ndc", "user"), lwd=1.5, xpd=NA)
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.93, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.93, "ndc", "user"), lwd=1.5, xpd=NA)
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)
sourceName
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))
i
i<-1
cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(0,2,0,0))#
		if (j == 2) par(mar = c(0,0,0,2))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
			heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}
?par
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))
cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]
for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,4,4,2))#
		if (j == 2) par(mar = c(5,4,4,2))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))
cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,2))#
		if (j == 2) par(mar = c(5,4,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}
dev.off()
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)
mtext(sourceName[2], line = -10, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[2], line = -17, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[3], line = -30, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[3], line = -35, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[3], line = -32, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -17, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -32, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -17, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -32, font=2, cex=0.8, at = 0.25, outer = TRUE)#
segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)
mtext(sourceName[5], line = -17, font=2, cex=0.8, at = 0.75, outer = TRUE)
mtext(sourceName[6], line = -32, font=2, cex=0.8, at = 0.75, outer = TRUE)
mtext(sourceName[3], line = -31, font=2, cex=0.8, at = 0.25, outer = TRUE)
mtext(sourceName[6], line = -31, font=2, cex=0.8, at = 0.75, outer = TRUE)
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -17, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -31, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -17, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -31, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -15, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -26, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -15, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -26, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -25, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -35, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -25, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -35, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -22, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -37, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -22, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -37, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(5,5,4,1))#
		if (j == 2) par(mar = c(5,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(4,5,4,1))#
		if (j == 2) par(mar = c(4,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(4,5,4,1))#
		if (j == 2) par(mar = c(4,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -2.2, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(4,5,4,1))#
		if (j == 2) par(mar = c(4,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -1.8, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(4,5,4,1))#
		if (j == 2) par(mar = c(4,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)))#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -1.5, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=10, height=7, units='in', res=300)#
#
layout(m)#
#
axisRange <- c(0, 0.6)#
tipMetrics <- c('lambdaDR','lambdaBAMM')#
tipMetricLabel <- c(expression(lambda['DR']),expression(lambda['BAMM']))#
#
for (i in 1:length(setlist)) {#
	cat(i, '\n')#
	qq <- dat[which(dat$setname %in% setlist[i]),]#
#
	for (j in 1:length(tipMetrics)) {#
		plot.new()#
		if (j == 1) par(mar = c(4,5,4,1))#
		if (j == 2) par(mar = c(4,3,4,3))#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, c(-1, axTicks(1)))#
		axis(2, c(-1, axTicks(2)), las=2)#
		mtext(expression(lambda['TRUE']), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		if (!all(is.na(qq[, tipMetrics[j]]))) {#
		#	heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
			r <- cor(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')#
			mtext(paste('r = ', round(r,3)), side=1, line = -1.5, adj = 0.95, cex=0.8)#
		}#
		abline(a=0, b=1, lty=3)#
	}#
}#
mtext(sourceName[1], line = -3, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[2], line = -20, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.84, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.84, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[3], line = -38, font=2, cex=0.8, at = 0.25, outer = TRUE)#
#segments(x0 = grconvertX(0.25, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.25, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[4], line = -3, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[5], line = -20, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
mtext(sourceName[6], line = -38, font=2, cex=0.8, at = 0.75, outer = TRUE)#
#segments(x0 = grconvertX(0.75, "ndc", "user") - 0.75, y0=grconvertY(0.94, "ndc", "user"), x1 = grconvertX(0.75, "ndc", "user") + 0.75, y1 = grconvertY(0.94, "ndc", "user"), lwd=1.5, xpd=NA)#
#
dev.off()
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
# leave out highTurnoverBD and LambdaEqualsMu#
dat <- dat[which(!dat$setname %in% c('highTurnoverBD', 'LambdaEqualsMu')), ]#
table(dat$setname)
setlist <- list('multi-regime'= c('fossilBAMM', 'lambdaConstantVariance','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')#
#
tipMetrics <- c('lambdaND','lambdaDR','lambdaBAMM')#
#
gridVal <- 1000#
#
tipMetricLabel <- c(expression(lambda['ND']), expression(lambda['DR']),expression(lambda['BAMM']))#
#
m <- rbind( c(10,10,10),#
			c(1,2,3),#
			c(11,11,11),#
			c(4,5,6),#
			c(12,12,12),#
			c(7,8,9))
gridVal <- 50
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -0.25, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.25, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.25, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -0.3, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.3, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.3, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -0.5, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.5, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -0.5, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -1, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}
titleSize <- 1.5
par(mar=c(1,1,1,1))
plot.new()
text(0.5, -1, 'multi-regime', font=2, xpd=NA, cex= titleSize)
text(0.5, -2, 'multi-regime', font=2, xpd=NA, cex= titleSize)
text(0.5, -5, 'multi-regime', font=2, xpd=NA, cex= titleSize)
text(0.5, -4, 'multi-regime', font=2, xpd=NA, cex= titleSize)
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -4, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -4, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -4, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -2, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -2, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -2, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -1, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
#		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -1.5, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1.5, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1.5, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
gridVal
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipLambda_main.png', width=9, height=9, units='in', res=300)#
layout(m, heights=rep(c(15/3, 85/3), times=3))#
#layout.show(max(m))#
#
par(mar=c(2,3,1,1), oma = c(2,2,0,0))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		qqSub <- qq[which(!is.na(qq[, tipMetrics[j]])),]#
		r <- cor(qqSub$tipLambda, qqSub[, tipMetrics[j]], method='spearman')#
		mtext(paste('r = ', round(r,2)), side=1, line = -1.5, adj = 0.95, cex=0.7)#
	}#
}#
#
titleSize <- 1.5#
par(mar=c(1,1,1,1))#
plot.new()#
text(0.5, -1.5, 'multi-regime', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1.5, 'diversity-dependent', font=2, xpd=NA, cex= titleSize)#
#
plot.new()#
text(0.5, -1.5, 'evolving rates', font=2, xpd=NA, cex= titleSize)#
dev.off()
require(TeachingDemos)#
#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)
# keep only single regime trees#
dat_lambda <- dat[which(dat$setname == 'lambdaConstantVariance'),]#
dat_netdiv <- dat[which(dat$setname == 'netDivConstantVariance'),]#
#
# get true relative extinction rate#
epsVec_lambda <- treeDat[which(treeDat$treeName %in% dat_lambda$treeName),]#
epsVec_lambda <- setNames(epsVec_lambda$mu0 / epsVec_lambda$lambda0, epsVec_lambda$treeName)#
epsVec_lambda <- epsVec_lambda[dat_lambda$treeName]#
#
epsVec_netdiv <- treeDat[which(treeDat$treeName %in% dat_netdiv$treeName),]#
epsVec_netdiv <- setNames(epsVec_netdiv$mu0 / epsVec_netdiv$lambda0, epsVec_netdiv$treeName)#
epsVec_netdiv <- epsVec_netdiv[dat_netdiv$treeName]#
tipMetrics <- c('lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
tipMetricLabel <- c(expression(bold(paste(lambda['ND']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))
# mean absolute error#
errorMetric <- 'absoluteError'#
#
yrange <- c(0,5)#
insetYrange <- c(0, 0.5)#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv.pdf', width=9, height=5)#
#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- expression(paste("mean absolute error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, dat_lambda[, errorCol], cex=0.3)#
	# mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=0, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, dat_lambda[, errorCol], cex=0.3)#
	}#
	subplot(insetMap(), x=0.5, y=1.5, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("mean absolute error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis=0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis=0.7)#
	points(epsVec_netdiv, dat_netdiv[, errorCol], cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic(r)['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=0, lty=2, col=gray(0.5), lwd=1)		#
}#
#
dev.off()
errorMetric <- 'PE1'#
#
yrange <- c(-1.5,4)#
insetYrange <- c(-0.4,0.6)#
constant <- 4#
width <- 0.03#
correction <- log(0 + constant)#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv_logPE1.pdf', width=9, height=5)#
#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}#
#
dev.off()
yrangeTop <- c(-0.5,4)#
yrangeBottom <- c(-1.5,4)#
insetYrange <- c(-0.4,0.6)#
constant <- 4#
width <- 0.03#
correction <- log(0 + constant)#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv_logPE1.pdf', width=9, height=5)#
#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeBottom)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}#
#
dev.off()
# Separate figure for lambdaTB, compared to lambdaDR and lambdaBAMM#
tipMetrics <- c('lambdaTB', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
tipMetricLabel <- c(expression(bold(paste(lambda['TB']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))#
#
# mean absolute error#
errorMetric <- 'absoluteError'#
#
yrange <- c(0,100)#
insetYrange <- c(0, 30)#
width <- 0.03#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaTB_absoluteError.pdf', width=9, height=5)#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- expression(paste("mean absolute error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, dat_lambda[, errorCol], cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=0, lty=2, col=gray(0.5), lwd=1)#
	# insetMap <- function() {#
		# plot.new()#
		# plot.window(xlim = c(0,1), ylim = insetYrange)#
		# axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		# axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		# points(epsVec_lambda, dat_lambda[, errorCol], cex=0.3)#
		# abline(h=0, lty=2, col=gray(0.5), lwd=1)#
	# }#
	# subplot(insetMap(), x=0.5, y=30, vadj=0, hadj=0, size=c(0.8,0.8), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("mean absolute error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrange)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis=0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis=0.7)#
	points(epsVec_netdiv, dat_netdiv[, errorCol], cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic(r)['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=0, lty=2, col=gray(0.5), lwd=1)	#
}#
#
dev.off()
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
#
# set infinite values to NA#
for (i in 6:ncol(dat)) {#
	if (length(which(!is.finite(dat[,i]))) > 0) {#
		dat[which(!is.finite(dat[,i])), i] <- NA#
	}#
}#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
#
# combined figure of all 5 tip rate metrics, under 3 scenarios#
## leaving lambdaTB out for a separate figure#
#
rateMetrics <- c('CRBDlambda', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
rateMetricLabels <- c(expression(bold(paste(lambda['CRBD']))), expression(bold(paste(lambda['ND']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=10, height=7)#
par(mfrow = c(3, 4), mar = c(4,3,3,1), oma = c(0,1,0,0))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.4)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = NA)#
	axis(1, at = c(0, 1:length(datSplit)), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)), cex.axis = 0.8, cex.axis = 0.9, mgp = c(3, 0.7, 0))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# title(main = 'multi-regime, time-constant', line = -1.5, cex.main=1.5, outer = TRUE, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.97, "ndc", "user"), 'multi-regime, time-constant', font=2, cex=1.5, xpd=NA)#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
defaultYrange <- c(0, 0.2)#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = NA)#
	axis(1, at = c(1, as.numeric(names(datSplit))), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-0.25, axTicks(2)), cex.axis = 0.8, mgp = c(3, 0.5, 0))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# mtext('multi-regime, diversity-dependent', line = 1.5, font=1, cex=1.5, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.64, "ndc", "user"), 'multi-regime, diversity-dependent', font=2, cex=1.5, xpd=NA)#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
defaultYrange <- c(0, 0.4)#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = NA)#
	axis(1, at = c(-0.5, 1:3), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)), cex.axis = 0.8, mgp = c(3, 0.5, 0))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext(expression(sigma), side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.3, "ndc", "user"), 'evolving rates', font=2, cex=1.5, xpd=NA)#
dev.off()
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
#
# set infinite values to NA#
for (i in 6:ncol(dat)) {#
	if (length(which(!is.finite(dat[,i]))) > 0) {#
		dat[which(!is.finite(dat[,i])), i] <- NA#
	}#
}#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
#
# combined figure of all 5 tip rate metrics, under 3 scenarios#
## leaving lambdaTB out for a separate figure#
#
rateMetrics <- c('CRBDlambda', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
rateMetricLabels <- c(expression(bold(paste(lambda['CRBD']))), expression(bold(paste(lambda['ND']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=10, height=7)#
par(mfrow = c(3, 4), mar = c(4,3,3,1), oma = c(0,1,0,0))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.4)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = NA)#
	axis(1, at = c(0, 1:length(datSplit)), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)), cex.axis = 0.8, cex.axis = 0.9, mgp = c(3, 0.7, 0))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# title(main = 'multi-regime, time-constant', line = -1.5, cex.main=1.5, outer = TRUE, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.97, "ndc", "user"), 'multi-regime', font=2, cex=1.5, xpd=NA)#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
defaultYrange <- c(0, 0.2)#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = NA)#
	axis(1, at = c(1, as.numeric(names(datSplit))), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-0.25, axTicks(2)), cex.axis = 0.8, mgp = c(3, 0.5, 0))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# mtext('multi-regime, diversity-dependent', line = 1.5, font=1, cex=1.5, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.64, "ndc", "user"), 'diversity-dependent', font=2, cex=1.5, xpd=NA)#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
defaultYrange <- c(0, 0.4)#
#
for (i in 1:4) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = NA)#
	axis(1, at = c(-0.5, 1:3), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)), cex.axis = 0.8, mgp = c(3, 0.5, 0))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext(expression(sigma), side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
	# if (i == 3) {#
		# title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	# }#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.3, "ndc", "user"), 'evolving rates', font=2, cex=1.5, xpd=NA)#
dev.off()
rateMetrics <- c('lambdaTB', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
rateMetricLabels <- c(expression(bold(paste(lambda['TB']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots_lambdaTB.pdf', width=7.5, height=7)#
par(mfrow = c(3, 3), mar = c(4,3,3,1), oma = c(0,1,0,0))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 15)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:3) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = defaultYrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = NA)#
	axis(1, at = c(0, 1:length(datSplit)), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.97, "ndc", "user"), 'multi-regime', font=2, cex=1.5, xpd=NA)#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
defaultYrange <- c(0, 3)#
#
for (i in 1:3) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = defaultYrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = NA)#
	axis(1, at = c(1, as.numeric(names(datSplit))), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-1, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('n regimes', side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.64, "ndc", "user"), 'diversity-dependent', font=2, cex=1.5, xpd=NA)#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
defaultYrange <- c(0, 15)#
#
for (i in 1:3) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = defaultYrange)#
	axis(1, at = c(-0.5, 1:3), labels = NA)#
	axis(1, at = c(-0.5, 1:3), tick=FALSE, labels = c(NA, names(datSplit)), lwd=0, cex.axis = 0.9, mgp = c(3, 0.7, 0), xpd=NA)#
	axis(2, at = c(-10, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1, xpd=NA)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1, xpd=NA)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1, xpd=NA)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1, xpd=NA)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1, xpd=NA)#
	}#
	abline(h=0, lty=3)#
	mtext(expression(sigma), side = 1, cex=0.7, line = 2)#
	if (i == 1) mtext('mean absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.5)#
}#
text(x=grconvertX(0.5, "ndc", "user"), y=grconvertY(0.3, "ndc", "user"), 'evolving rates', font=2, cex=1.5, xpd=NA)#
dev.off()
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)#
#
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
#
# # Examine strength of estimated-to-true rate correlation across regimes, as a function of regime size. #
# # Use only multi-regime time-constant trees#
# # Regime size along x-axis and Pearson correlation coefficient and slope as y-axis#
#
regimeSummary2 <- regimeSummary[which(regimeSummary$setname %in% c('MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017')),]#
#
maxRegimeCount <- 50#
#
regimeSize <- sort(unique(regimeSummary2$nTips))#
#
regimeSize <- 1:maxRegimeCount#
#
rateMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
regimeSizeTable <- as.data.frame(matrix(nrow = length(regimeSize), ncol = 21))#
colnames(regimeSizeTable) <- c('regimeSize', paste0(rateMetrics, 'lambda_cor'), paste0(rateMetrics, 'lambda_slope'), paste0(rateMetricsNetDiv, 'netdiv_cor'), paste0(rateMetricsNetDiv, 'netdiv_slope'))#
regimeSizeTable$regimeSize <- regimeSize#
#
for (i in 1:length(regimeSize)) {#
	xx <- regimeSummary2[which(regimeSummary2$nTips >= regimeSize[i]),]#
	# speciation rate#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_cor')] <- cor(xx$tipLambda, xx[, rateMetrics[j]])#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_slope')] <- summary(lm(xx[, rateMetrics[j]] ~ xx$tipLambda))$coef[2,1]#
		}#
	}#
	# net diversification#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_cor')] <- cor(xx$tipNetDiv, xx[, rateMetricsNetDiv[j]])#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_slope')] <- summary(lm(xx[, rateMetricsNetDiv[j]] ~ xx$tipNetDiv))$coef[2,1]#
		}#
	}#
}
# Speciation rate, Pearson correlation#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
metricColors <- c('black','dark green','dark orange','red','blue')#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByMinRegimeSize_lambda.pdf', width=10, height=5)#
#
par(mfrow=c(1,2), mar=c(4,4,0,0))#
#
# speciation rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.5, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.5, cex=1)#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
mtext('(a)', outer = TRUE, line = -1.5, at = 0.02, font=2)#
#
#legend(35, 0.5, legend = c('CRBD','TB','ND','DR','BAMM'), col = metricColors, lwd=2, bty='n', xpd=NA)#
legend(35, 0.55, legend = c(expression(lambda['CRBD']), expression(lambda['TB']), expression(lambda['ND']), expression(lambda['DR']), expression(lambda['BAMM'])), col = metricColors, lwd=2, bty='n', xpd=NA, cex=1.2)#
#
# speciation rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.5))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.5, cex=1)#
mtext('OLS slope', side = 2, line = 2.5, cex=1)#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
mtext('(b)', outer = TRUE, line = -1.5, at = 0.52, font=2)#
#
dev.off()
# Now, net div#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByMinRegimeSize_netDiv.pdf', width=10, height=5)#
#
par(mfrow=c(1,2), mar=c(4,4,0,0))#
#
# net div rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.5, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.5, cex=1)#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
mtext('(a)', outer = TRUE, line = -1.5, at = 0.02, font=2)#
#
legend(35, 0.97, legend = c(expression(italic(r)['CRBD']), expression(lambda['TB']), expression(lambda['ND']), expression(lambda['DR']), expression(italic(r)['BAMM'])), col = metricColors, lwd=2, bty='n', xpd=NA, cex=1.2)#
# net div rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.5))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.5, cex=1)#
mtext('OLS slope', side = 2, line = 2.5, cex=1)#
#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
mtext('(b)', outer = TRUE, line = -1.5, at = 0.52, font=2)#
#
dev.off()
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
listnames <- names(allRatesList)#
listnames <- sapply(listnames, function(x) strsplit(x, '_')[[1]][1], USE.NAMES=FALSE)#
allRatesList <- allRatesList[which(listnames %in% c('MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017'))]#
#
# combine treeName and regimeID to create one big lookup table#
for (i in 1:length(allRatesList)) {#
	allRatesList[[i]]$regimeID <- paste0(allRatesList[[i]]$treeName, '_', allRatesList[[i]]$regimeID)#
}#
allRates <- do.call(rbind, allRatesList)#
allRates$CRBDnetdiv <- allRates$CRBDlambda - allRates$CRBDmu#
#
# average each regime #
regimeAvg <- matrix(nrow = length(unique(allRates$regimeID)), ncol = 13)#
colnames(regimeAvg) <- c('treeName', 'regimeSize', 'tipLambda', 'tipNetDiv', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM', 'CRBDlambda', 'CRBDnetdiv', 'lambdaSpectr', 'netDivSpectr')#
regimeAvg <- as.data.frame(regimeAvg, stringsAsFactors=FALSE)#
for (i in 1:length(unique(allRates$regimeID))) {#
	qq <- allRates[which(allRates$regimeID == unique(allRates$regimeID)[i]),]#
	regimeAvg[i, 'treeName'] <- qq[1, 'treeName']#
	regimeAvg[i, 'regimeSize'] <- nrow(qq)#
	regimeAvg[i, 'tipLambda'] <- mean(qq[, 'tipLambda'])#
	regimeAvg[i, 'tipNetDiv'] <- mean(qq[, 'tipNetDiv'])#
	regimeAvg[i, 'lambdaTB'] <- mean(qq[, 'lambdaTB'])#
	regimeAvg[i, 'lambdaND'] <- mean(qq[, 'lambdaND'])#
	regimeAvg[i, 'lambdaDR'] <- mean(qq[, 'lambdaDR'])#
	regimeAvg[i, 'lambdaBAMM'] <- mean(qq[, 'lambdaBAMM'])#
	regimeAvg[i, 'netDivBAMM'] <- mean(qq[, 'netDivBAMM'])#
	regimeAvg[i, 'CRBDlambda'] <- mean(qq[, 'CRBDlambda'])#
	regimeAvg[i, 'CRBDnetdiv'] <- mean(qq[, 'CRBDnetdiv'])#
	regimeAvg[i, 'lambdaSpectr'] <- mean(qq[, 'lambdaSpectr'])#
	regimeAvg[i, 'netDivSpectr'] <- mean(qq[, 'netDivSpectr'])#
}#
#
regimeAvgError <- matrix(nrow = nrow(regimeAvg), ncol = 14)#
colnames(regimeAvgError) <- c('treeName','regimeSize','lambdaError_lambdaTB', 'lambdaError_lambdaND', 'lambdaError_lambdaDR', 'lambdaError_lambdaBAMM', 'lambdaError_CRBDlambda', 'lambdaError_lambdaSpectr', 'netdivError_lambdaTB', 'netdivError_lambdaND', 'netdivError_lambdaDR', 'netdivError_netDivBAMM', 'netdivError_CRBDnetdiv', 'netdivError_netDivSpectr')#
regimeAvgError <- as.data.frame(regimeAvgError, stringsAsFactors=FALSE)#
#
for (i in 1:nrow(regimeAvg)) {#
	regimeAvgError[i, 'treeName'] <- regimeAvg[i, 'treeName']#
	regimeAvgError[i, 'regimeSize'] <- regimeAvg[i, 'regimeSize']#
	regimeAvgError[i, 'lambdaError_lambdaTB'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaTB'])#
	regimeAvgError[i, 'lambdaError_lambdaND'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaND'])#
	regimeAvgError[i, 'lambdaError_lambdaDR'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaDR'])#
	regimeAvgError[i, 'lambdaError_lambdaBAMM'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaBAMM'])#
	regimeAvgError[i, 'lambdaError_CRBDlambda'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'CRBDlambda'])#
	regimeAvgError[i, 'lambdaError_lambdaSpectr'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaSpectr'])#
#
	regimeAvgError[i, 'netdivError_lambdaTB'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaTB'])#
	regimeAvgError[i, 'netdivError_lambdaND'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaND'])#
	regimeAvgError[i, 'netdivError_lambdaDR'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaDR'])#
	regimeAvgError[i, 'netdivError_netDivBAMM'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'netDivBAMM'])#
	regimeAvgError[i, 'netdivError_CRBDnetdiv'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'CRBDnetdiv'])#
	regimeAvgError[i, 'netdivError_netDivSpectr'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'netDivSpectr'])#
}#
#
rateMetrics <- c('CRBDlambda','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaND','lambdaDR','netDivBAMM')#
#
# bin into 10 tip groupings#
#
brks <- c(1,10,20,30,40,50)#
#
defaultYrange <- c(0, 0.5)#
width <- 0.4#
#
rateMetricLabels <- c(expression(bold(lambda['CRBD'])), expression(bold(lambda['ND'])), expression(bold(lambda['DR'])),expression(bold(lambda['BAMM'])))#
#
rateMetricLabelsNetDiv <- c(expression(bold(italic(r)['CRBD'])), expression(bold(lambda['TB'])), expression(bold(lambda['ND'])), expression(bold(lambda['DR'])),expression(bold(italic(r)['BAMM'])))
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanError_across_regimeSize.pdf', width=10, height=3)#
par(mfrow = c(1, 4), mar = c(5,3,0,0), oma = c(0,1,1,0))#
for (i in 1:length(rateMetrics)) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- intersect(grep('lambdaError', colnames(regimeAvgError)), grep(tipMetric, colnames(regimeAvgError)))#
	plot.new()#
	plot.window(xlim = c(0.5,6.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:6), labels = FALSE)#
	text(x = (1:6) + 0.35, y = -0.05, labels = c('1-10', '11-20','21-30','31-40','41-50','> 50'), srt=35, pos=2, xpd=NA)#
	axis(2, at = c(-10, axTicks(2)))#
	for (j in 1:length(brks)) {#
#
		if (j < 6) {#
			qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))#
		} else {#
			qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))#
		}#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1, xpd =NA)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1, xpd =NA)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1, xpd =NA)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1, xpd =NA)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1, xpd =NA)#
	}#
	abline(h=0, lty=3)#
	mtext('regime size', side = 1, cex=0.7, line = 3)#
	if (i == 1) mtext('absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.6, cex.main=1.2)#
}#
#
dev.off()
yrange <- c(0, 0.5)
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanError_across_regimeSize.pdf', width=10, height=3)#
par(mfrow = c(1, 4), mar = c(5,3,0,0), oma = c(0,1,1,0))#
for (i in 1:length(rateMetrics)) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- intersect(grep('lambdaError', colnames(regimeAvgError)), grep(tipMetric, colnames(regimeAvgError)))#
	plot.new()#
	plot.window(xlim = c(0.5,6.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:6), labels = FALSE)#
	text(x = (1:6) + 0.35, y = -0.05, labels = c('1-10', '11-20','21-30','31-40','41-50','> 50'), srt=35, pos=2, xpd=NA)#
	axis(2, at = c(-10, axTicks(2)))#
	for (j in 1:length(brks)) {#
#
		if (j < 6) {#
			qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))#
		} else {#
			qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))#
		}#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1, xpd =NA)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1, xpd =NA)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1, xpd =NA)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1, xpd =NA)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1, xpd =NA)#
	}#
	abline(h=0, lty=3)#
	mtext('regime size', side = 1, cex=0.7, line = 3)#
	if (i == 1) mtext('absolute error', side = 2, cex=0.7, line = 2.5)#
	title(main = rateMetricLabels[i], line = -0.6, cex.main=1.2)#
}#
#
dev.off()
# Analyze estimated rates as a function of true rates, when averaged by true regimes#
#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)#
#
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
#
# # Examine strength of estimated-to-true rate correlation across regimes, as a function of regime size. #
# # Use only multi-regime time-constant trees#
# # Regime size along x-axis and Pearson correlation coefficient and slope as y-axis#
#
regimeSummary2 <- regimeSummary[which(regimeSummary$setname %in% c('MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017')),]#
#
maxRegimeCount <- 50#
#
regimeSize <- sort(unique(regimeSummary2$nTips))#
#
regimeSize <- 1:maxRegimeCount#
#
rateMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
regimeSizeTable <- as.data.frame(matrix(nrow = length(regimeSize), ncol = 21))#
colnames(regimeSizeTable) <- c('regimeSize', paste0(rateMetrics, 'lambda_cor'), paste0(rateMetrics, 'lambda_slope'), paste0(rateMetricsNetDiv, 'netdiv_cor'), paste0(rateMetricsNetDiv, 'netdiv_slope'))#
regimeSizeTable$regimeSize <- regimeSize#
#
for (i in 1:length(regimeSize)) {#
	xx <- regimeSummary2[which(regimeSummary2$nTips >= regimeSize[i]),]#
	# speciation rate#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_cor')] <- cor(xx$tipLambda, xx[, rateMetrics[j]])#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_slope')] <- summary(lm(xx[, rateMetrics[j]] ~ xx$tipLambda))$coef[2,1]#
		}#
	}#
	# net diversification#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_cor')] <- cor(xx$tipNetDiv, xx[, rateMetricsNetDiv[j]])#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_slope')] <- summary(lm(xx[, rateMetricsNetDiv[j]] ~ xx$tipNetDiv))$coef[2,1]#
		}#
	}#
}
# Calculate absolute and proportional error as a function of regime size#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
listnames <- names(allRatesList)#
listnames <- sapply(listnames, function(x) strsplit(x, '_')[[1]][1], USE.NAMES=FALSE)#
allRatesList <- allRatesList[which(listnames %in% c('MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017'))]#
#
# combine treeName and regimeID to create one big lookup table#
for (i in 1:length(allRatesList)) {#
	allRatesList[[i]]$regimeID <- paste0(allRatesList[[i]]$treeName, '_', allRatesList[[i]]$regimeID)#
}#
allRates <- do.call(rbind, allRatesList)#
allRates$CRBDnetdiv <- allRates$CRBDlambda - allRates$CRBDmu#
#
# average each regime #
regimeAvg <- matrix(nrow = length(unique(allRates$regimeID)), ncol = 13)#
colnames(regimeAvg) <- c('treeName', 'regimeSize', 'tipLambda', 'tipNetDiv', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM', 'CRBDlambda', 'CRBDnetdiv', 'lambdaSpectr', 'netDivSpectr')#
regimeAvg <- as.data.frame(regimeAvg, stringsAsFactors=FALSE)#
for (i in 1:length(unique(allRates$regimeID))) {#
	qq <- allRates[which(allRates$regimeID == unique(allRates$regimeID)[i]),]#
	regimeAvg[i, 'treeName'] <- qq[1, 'treeName']#
	regimeAvg[i, 'regimeSize'] <- nrow(qq)#
	regimeAvg[i, 'tipLambda'] <- mean(qq[, 'tipLambda'])#
	regimeAvg[i, 'tipNetDiv'] <- mean(qq[, 'tipNetDiv'])#
	regimeAvg[i, 'lambdaTB'] <- mean(qq[, 'lambdaTB'])#
	regimeAvg[i, 'lambdaND'] <- mean(qq[, 'lambdaND'])#
	regimeAvg[i, 'lambdaDR'] <- mean(qq[, 'lambdaDR'])#
	regimeAvg[i, 'lambdaBAMM'] <- mean(qq[, 'lambdaBAMM'])#
	regimeAvg[i, 'netDivBAMM'] <- mean(qq[, 'netDivBAMM'])#
	regimeAvg[i, 'CRBDlambda'] <- mean(qq[, 'CRBDlambda'])#
	regimeAvg[i, 'CRBDnetdiv'] <- mean(qq[, 'CRBDnetdiv'])#
	regimeAvg[i, 'lambdaSpectr'] <- mean(qq[, 'lambdaSpectr'])#
	regimeAvg[i, 'netDivSpectr'] <- mean(qq[, 'netDivSpectr'])#
}#
#
regimeAvgError <- matrix(nrow = nrow(regimeAvg), ncol = 14)#
colnames(regimeAvgError) <- c('treeName','regimeSize','lambdaError_lambdaTB', 'lambdaError_lambdaND', 'lambdaError_lambdaDR', 'lambdaError_lambdaBAMM', 'lambdaError_CRBDlambda', 'lambdaError_lambdaSpectr', 'netdivError_lambdaTB', 'netdivError_lambdaND', 'netdivError_lambdaDR', 'netdivError_netDivBAMM', 'netdivError_CRBDnetdiv', 'netdivError_netDivSpectr')#
regimeAvgError <- as.data.frame(regimeAvgError, stringsAsFactors=FALSE)#
#
for (i in 1:nrow(regimeAvg)) {#
	regimeAvgError[i, 'treeName'] <- regimeAvg[i, 'treeName']#
	regimeAvgError[i, 'regimeSize'] <- regimeAvg[i, 'regimeSize']#
	regimeAvgError[i, 'lambdaError_lambdaTB'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaTB'])#
	regimeAvgError[i, 'lambdaError_lambdaND'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaND'])#
	regimeAvgError[i, 'lambdaError_lambdaDR'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaDR'])#
	regimeAvgError[i, 'lambdaError_lambdaBAMM'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaBAMM'])#
	regimeAvgError[i, 'lambdaError_CRBDlambda'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'CRBDlambda'])#
	regimeAvgError[i, 'lambdaError_lambdaSpectr'] <- abs(regimeAvg[i, 'tipLambda'] - regimeAvg[i, 'lambdaSpectr'])#
#
	regimeAvgError[i, 'netdivError_lambdaTB'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaTB'])#
	regimeAvgError[i, 'netdivError_lambdaND'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaND'])#
	regimeAvgError[i, 'netdivError_lambdaDR'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'lambdaDR'])#
	regimeAvgError[i, 'netdivError_netDivBAMM'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'netDivBAMM'])#
	regimeAvgError[i, 'netdivError_CRBDnetdiv'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'CRBDnetdiv'])#
	regimeAvgError[i, 'netdivError_netDivSpectr'] <- abs(regimeAvg[i, 'tipNetDiv'] - regimeAvg[i, 'netDivSpectr'])#
}#
#
rateMetrics <- c('CRBDlambda','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaND','lambdaDR','netDivBAMM')#
#
# bin into 10 tip groupings#
#
brks <- c(1,10,20,30,40,50)#
#
yrange <- c(0, 0.5)#
width <- 0.4#
#
rateMetricLabels <- c(expression(bold(lambda['CRBD'])), expression(bold(lambda['ND'])), expression(bold(lambda['DR'])),expression(bold(lambda['BAMM'])))#
#
rateMetricLabelsNetDiv <- c(expression(bold(italic(r)['CRBD'])), expression(bold(lambda['TB'])), expression(bold(lambda['ND'])), expression(bold(lambda['DR'])),expression(bold(italic(r)['BAMM'])))
i<-3
j<-1
tipMetric <- rateMetrics[i]
errorCol <- intersect(grep('lambdaError', colnames(regimeAvgError)), grep(tipMetric, colnames(regimeAvgError)))
j < 6
qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))
qStats
mean(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol])
i<-2
tipMetric <- rateMetrics[i]#
	errorCol <- intersect(grep('lambdaError', colnames(regimeAvgError)), grep(tipMetric, colnames(regimeAvgError)))
qStats <- quantile(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol], c(0.05, 0.25, 0.5, 0.75, 0.95))
qStats
mean(regimeAvgError[which(regimeAvgError[, 'regimeSize'] > brks[j] & regimeAvgError[, 'regimeSize'] <= brks[j+1]), errorCol])
# analyze proportional error in rates as a function of relative extinction#
# compare speciation rate and net diversification rate#
#
require(TeachingDemos)#
#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error of lambda and lambda - mu against eps#
# first for single regime trees#
# keep only single regime trees#
dat_lambda <- dat[which(dat$setname == 'lambdaConstantVariance'),]#
dat_netdiv <- dat[which(dat$setname == 'netDivConstantVariance'),]#
#
# get true relative extinction rate#
epsVec_lambda <- treeDat[which(treeDat$treeName %in% dat_lambda$treeName),]#
epsVec_lambda <- setNames(epsVec_lambda$mu0 / epsVec_lambda$lambda0, epsVec_lambda$treeName)#
epsVec_lambda <- epsVec_lambda[dat_lambda$treeName]#
#
epsVec_netdiv <- treeDat[which(treeDat$treeName %in% dat_netdiv$treeName),]#
epsVec_netdiv <- setNames(epsVec_netdiv$mu0 / epsVec_netdiv$lambda0, epsVec_netdiv$treeName)#
epsVec_netdiv <- epsVec_netdiv[dat_netdiv$treeName]#
tipMetrics <- c('lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
tipMetricLabel <- c(expression(bold(paste(lambda['ND']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))
errorMetric <- 'PE1'#
#
yrangeTop <- c(-0.5,4)#
yrangeBottom <- c(-1.5,4)#
insetYrange <- c(-0.4,0.6)#
constant <- 4#
width <- 0.03#
correction <- log(0 + constant)
log(1)
correction <- log(1 + constant)
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeBottom)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv_logPE1.pdf', width=9, height=5)#
#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeBottom)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}#
#
dev.off()
log(0 + constant)
log(1 + constant)
log(0 + constant) - correction
log(1 + constant) - correction
log(1 + constant)
i<-1
i<-4
tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)
correction
log(1 + constant)
points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)
tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)
errorMetric <- 'PE1'#
#
yrangeTop <- c(-0.5,4)#
yrangeBottom <- c(-1.5,4)#
insetYrange <- c(-0.4,0.6)#
constant <- 4#
width <- 0.03#
correction <- log(1 + constant)
tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)
correction
log(dat_lambda[, errorCol] + constant) - correction
tipMetrics
i
i<-3
tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)
points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) + correction, cex=0.3)
mean(dat_lambda[, errorCol])
errorCol
log(1)
colnames(dat_lambda)[errorCol]
# overall mean proportional error#
propError1 <- function(estimated, true) {#
	sum((estimated - true) / true) / length(true)#
}
propError1(c(4.9, 5.1), c(5,5))
errorMetric <- 'PE1'#
#
yrangeTop <- c(-0.5,4)#
yrangeBottom <- c(-1.5,4)#
insetYrange <- c(-0.4,0.6)#
constant <- 4#
width <- 0.03#
correction <- log(0 + constant)
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeBottom)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv_logPE1.pdf', width=9, height=5)#
#
layout(matrix(1:6, nrow=2,ncol=3, byrow=T))#
par(mar = c(3,3,0,0), oma=c(1,1,1,0))#
for (i in 1:3) {#
	tipMetric <- tipMetrics[i]#
	errorLabel <- errorLabel <- expression(paste("log prop. error in ", lambda))#
	errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeTop)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	title(main = tipMetricLabel[i], line = -1, cex.main=1.5)#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	insetMap <- function() {#
		plot.new()#
		plot.window(xlim = c(0,1), ylim = insetYrange)#
		axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7, tcl = -0.2, mgp = c(3,0.3,0), las = 1)#
		points(epsVec_lambda, log(dat_lambda[, errorCol] + constant) - correction, cex=0.3)#
		abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
	}#
	subplot(insetMap(), x=0.5, y=1, vadj=0, hadj=0, size=c(1,1), type='plt')#
}#
#
# second row: net div#
for (i in 1:3) {#
	tipMetric <- tipMetricsNetDiv[i]#
	errorLabel <- expression(paste("log prop. error in ", italic('r')))#
	errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,1), ylim = yrangeBottom)#
	axis(1, at=c(-0.1, axTicks(1)), cex.axis = 0.7)#
	axis(2, at=c(-5, axTicks(2)), cex.axis = 0.7)#
	points(epsVec_netdiv, log(dat_netdiv[, errorCol] + constant) - correction, cex=0.3)#
	mtext(expression(mu~'/'~lambda), side = 1, cex=0.8, line = 2.5)#
	if (i == 1) mtext(errorLabel, side = 2, cex=0.7, line = 2.5)#
	if (tipMetric == 'netDivBAMM') {#
		title(main = expression(bold(paste(italic('r')['BAMM']))), line = -2, cex.main=1.5)#
	}#
	abline(h=log(0 + constant) - correction, lty=2, col=gray(0.5), lwd=1)#
}#
#
dev.off()
# Analyze estimated rates as a function of true rates, when averaged by true regimes#
#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)#
#
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
#
# # Examine strength of estimated-to-true rate correlation across regimes, as a function of regime size. #
# # Use only multi-regime time-constant trees#
# # Regime size along x-axis and Pearson correlation coefficient and slope as y-axis#
#
regimeSummary2 <- regimeSummary[which(regimeSummary$setname %in% c('MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017')),]#
#
maxRegimeCount <- 50#
#
regimeSize <- sort(unique(regimeSummary2$nTips))#
#
regimeSize <- 1:maxRegimeCount#
#
rateMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
regimeSizeTable <- as.data.frame(matrix(nrow = length(regimeSize), ncol = 21))#
colnames(regimeSizeTable) <- c('regimeSize', paste0(rateMetrics, 'lambda_cor'), paste0(rateMetrics, 'lambda_slope'), paste0(rateMetricsNetDiv, 'netdiv_cor'), paste0(rateMetricsNetDiv, 'netdiv_slope'))#
regimeSizeTable$regimeSize <- regimeSize#
#
for (i in 1:length(regimeSize)) {#
	xx <- regimeSummary2[which(regimeSummary2$nTips >= regimeSize[i]),]#
	# speciation rate#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_cor')] <- cor(xx$tipLambda, xx[, rateMetrics[j]])#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_slope')] <- summary(lm(xx[, rateMetrics[j]] ~ xx$tipLambda))$coef[2,1]#
		}#
	}#
	# net diversification#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_cor')] <- cor(xx$tipNetDiv, xx[, rateMetricsNetDiv[j]])#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_slope')] <- summary(lm(xx[, rateMetricsNetDiv[j]] ~ xx$tipNetDiv))$coef[2,1]#
		}#
	}#
}
i<-5
# Speciation rate, Pearson correlation#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
metricColors <- c('black','dark green','dark orange','red','blue')
regimeSize
cbind(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_slope')])
rateMetricsNetDiv
i
cbind(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_slope')])
# plot tip rate values against each other, no by-tree or by-regime summarizing#
#
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
# leave out highTurnoverBD and LambdaEqualsMu#
dat <- dat[which(!dat$setname %in% c('highTurnoverBD', 'LambdaEqualsMu')), ]#
table(dat$setname)
setlist <- list('multi-regime'= c('fossilBAMM', 'lambdaConstantVariance','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')
tipMetrics <- c('lambdaND','lambdaDR','lambdaBAMM')
gridVal <- 50
tipMetricLabel <- c(expression(lambda['ND']), expression(lambda['DR']),expression(lambda['BAMM']))#
#
m <- rbind( c(10,10,10),#
			c(1,2,3),#
			c(11,11,11),#
			c(4,5,6),#
			c(12,12,12),#
			c(7,8,9))
tipMetrics
i<-1
j<-1
i<-2
qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
	axisRange <- quantile(qq$tipLambda, c(0, 0.99))
cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)
axisRange<-0,1
axisRange<-0:1
cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)#
		mtext(tipMetricLabel[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
class(qq[, tipMetrics[j]])
length(qq[, tipMetrics[j]])
head(qq[, tipMetrics[j]])
i
i<-1
qq <- dat[which(dat$setname %in% setlist[[i]]),]
head(qq[, tipMetrics[j]])
range(dat[which(dat$setname %in% setlist[[i]]),])
range(qq[, tipMetrics[j]])
i<-2
qq <- dat[which(dat$setname %in% setlist[[i]]),]
j
range(qq[, tipMetrics[j]])
i
i<-1
qq <- dat[which(dat$setname %in% setlist[[i]]),]
range(qq[, tipMetrics[j]])
tipMetricLabel[j]
range(qq$tipLambda)
plot(qq$tipLambda, qq[, tipMetrics[j]], cex=0.2)
i
i<-2
qq <- dat[which(dat$setname %in% setlist[[i]]),]
plot(qq$tipLambda, qq[, tipMetrics[j]], cex=0.2)
range(qq$tipLambda)
qq <- dat[which(dat$setname %in% setlist[[1]]),]
range(qq$tipLambda)
qq <- dat[which(dat$setname == 'Rabosky2014_DD_k1'),]
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
qq <- dat[which(dat$setname == 'Rabosky2014_DD_k2'),]
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
qq <- dat[which(dat$setname == 'Rabosky2014_DD_k3'),]
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
i<-1
qq <- dat[which(dat$setname %in% setlist[[i]]),]
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = c(0,0.15), ylim=c(0, 0.15))
plot.new()
plot.window(xlim = c(0,0.15), ylim = c(0,0.15))
axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))
mtext(expression(paste(lambda['TRUE'])), side=1, line = 2.5)
mtext(tipMetricLabel[j], side=2, line = 2.5)
heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal, xlim = axisRange, ylim = axisRange)
segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)
title(main = 'multi-regime, zoomed in')
require(TeachingDemos)#
#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error of lambda and lambda - mu against eps#
# first for single regime trees#
# keep only single regime trees#
dat_lambda <- dat[which(dat$setname == 'lambdaConstantVariance'),]#
dat_netdiv <- dat[which(dat$setname == 'netDivConstantVariance'),]#
#
# get true relative extinction rate#
epsVec_lambda <- treeDat[which(treeDat$treeName %in% dat_lambda$treeName),]#
epsVec_lambda <- setNames(epsVec_lambda$mu0 / epsVec_lambda$lambda0, epsVec_lambda$treeName)#
epsVec_lambda <- epsVec_lambda[dat_lambda$treeName]#
#
epsVec_netdiv <- treeDat[which(treeDat$treeName %in% dat_netdiv$treeName),]#
epsVec_netdiv <- setNames(epsVec_netdiv$mu0 / epsVec_netdiv$lambda0, epsVec_netdiv$treeName)#
epsVec_netdiv <- epsVec_netdiv[dat_netdiv$treeName]#
tipMetrics <- c('lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
#
tipMetricLabel <- c(expression(bold(paste(lambda['ND']))), expression(bold(paste(lambda['DR']))),expression(bold(paste(lambda['BAMM']))))
# mean absolute error#
errorMetric <- 'absoluteError'#
#
yrange <- c(0,5)#
insetYrange <- c(0, 0.5)
set1params <- read.csv('~/Dropbox/tipRatesProject/simulations/constantVariance/set1params.csv')#
set2params <- read.csv('~/Dropbox/tipRatesProject/simulations/constantVariance/set2params.csv')
plot.new()
text(0.5, 0.2, 'simulations for evaluating net diversification rate', pos=1, cex=1.5, font=2, xpd=NA)
plot.new()
plot.window(xlim = c(0,1), ylim = c(0, 10))
axis(1, at = c(-0.5, axTicks(1)))
axis(2, at = c(-0.5, axTicks(2)))
points(set2params$eps, set2params$lambda, cex=0.5)
mtext(expression(italic(r)=mu~'/'~lambda), side=1, line=2.5)
mtext(expression(italic(r)==mu~'/'~lambda), side=1, line=2.5)
mtext(expression(italic(r)==mu~'/'~lambda), side=1, line=1)
m <- matrix(c(1,1,2,3,4,4,5,6), nrow=4, ncol=2, byrow=TRUE)#
layout(m, heights=c(0.1, 0.4, 0.1, 0.4))#
#
par(mar=c(4,4,0,1))#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating speciation rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$lambda, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$netdiv, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda~'-'~mu), side=2, line=2.5)#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating net diversification rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 10))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$lambda, cex=0.5)#
mtext(expression(italic(r)==mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$netdiv, cex=0.5)#
mtext(expression(italic(r)==mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda~'-'~mu), side=2, line=2.5)
layout(m, heights=c(0.1, 0.4, 0.1, 0.4))#
#
par(mar=c(4,4,0,1))#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating speciation rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$lambda, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$netdiv, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(italic(r)==lambda~'-'~mu), side=2, line=2.5)#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating net diversification rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 10))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$lambda, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$netdiv, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)
mtext(expression(italic(r)==lambda~'-'~mu), side=2, line=2.5)
pdf('~/Dropbox/tipRatesProject/preliminaryplots/epsilonSimulationPlots.pdf', width=7, height=7)#
m <- matrix(c(1,1,2,3,4,4,5,6), nrow=4, ncol=2, byrow=TRUE)#
layout(m, heights=c(0.1, 0.4, 0.1, 0.4))#
#
par(mar=c(4,4,0,1))#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating speciation rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$lambda, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set1params$eps, set1params$netdiv, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(italic(r)==lambda~'-'~mu), side=2, line=2.5)#
#
plot.new()#
text(0.5, 0.2, 'simulations for evaluating net diversification rate', pos=1, cex=1.5, font=2, xpd=NA)#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 10))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$lambda, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(lambda), side=2, line=2.5)#
#
plot.new()#
plot.window(xlim = c(0,1), ylim = c(0, 0.3))#
axis(1, at = c(-0.5, axTicks(1)))#
axis(2, at = c(-0.5, axTicks(2)))#
points(set2params$eps, set2params$netdiv, cex=0.5)#
mtext(expression(mu~'/'~lambda), side=1, line=2.5)#
mtext(expression(italic(r)==lambda~'-'~mu), side=2, line=2.5)#
#
dev.off()
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
# leave out highTurnoverBD and LambdaEqualsMu#
dat <- dat[which(!dat$setname %in% c('highTurnoverBD', 'LambdaEqualsMu')), ]#
table(dat$setname)
head(dat)
setlist <- list('multi-regime'= c('fossilBAMM', 'lambdaConstantVariance','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')
setlist
nrow(dat[which(dat$setname == 'fossilBAMM'), 'treeName'])
head
head(dat[which(dat$setname == 'fossilBAMM'), 'treeName'])
length(unique((dat[which(dat$setname == 'fossilBAMM'), 'treeName']))
)
length(unique((dat[which(dat$setname == 'MooreEtAl2016'), 'treeName'])))
length(unique((dat[which(dat$setname == 'RaboskyEtAl2017'), 'treeName'])))
require(BAMMtools)#
require(phytools)#
#
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')#
source('~/Dropbox/tipRatesProject/sourceFxns.R')#
#
# # simulate a phylogeny, and graft in a subclade under a faster speciation rate#
# ## set the birth rate based on n1 & t=100#
# n1 <- 40#
# b1<-(log(n1)-log(2))/100#
# b1#
#
# tree<-pbtree(b=b1,t=100,n= n1)#
#
# ## pick a split point at 75% of total tree height#
# pp<-0.75#
# H<-nodeHeights(tree)#
# node<-sample(tree$edge[(H[,1]<pp*max(H)) + (H[,2]>pp*max(H))==2,2],1)#
# node#
#
# ## split the tree & this point#
# tree<-splitTree(tree,split=list(node=node, bp=pp*max(H)-H[which(tree$edge[,2]==node),1]))[[1]]#
# tree$tip.label[tree$tip.label=="NA"]<-""#
# plotTree(tree,mar=c(3.1,0.1,0.1,0.1))#
# axis(1)#
# nodelabels(node=tree$tip.label=="",pch=19)#
# shiftStartTime <- sum(tree$edge.length[root2tipEdges(tree, '')])#
# abline(v=shiftStartTime, lty=3)#
#
# ## set the second desired birth-rate based on n=n2 & t=25#
# ## note this time we want to start with 1 lineage, not 2#
# n2 <- 30#
# b2<-log(n2)/(max(H)-pp*max(H))#
# ## simulate the "stem" of the new subtree#
# t1<-(max(H)-pp*max(H))#
# while(t1>=25) t1<-rexp(n=1,rate=b2)#
#
# ## add the stem#
# ii<-which(tree$edge[,2]==which(tree$tip.label==""))#
# tree$edge.length[ii]<-tree$edge.length[ii]+t1#
#
# plotTree(tree,mar=c(3.1,0.1,0.1,0.1))#
# axis(1)#
# nodelabels(node=tree$tip.label=="",pch=19)#
#
# ## now simulate the rest of the derived subtree#
# t2<-pbtree(b=b2,t=max(nodeHeights(tree)) -  nodeheight(tree,which(tree$tip.label=="")),n= n2)#
# t2$tip.label<-paste("s",1:Ntip(t2),sep="")#
# tree<-bind.tree(tree,t2,where=which(tree$tip.label==""))#
# plotTree(tree,fsize=0.8,mar=c(3.1,0.1,0.1,0.1))#
# axis(1)#
# nodelabels(node=getMRCA(tree, t2$tip.label))#
# abline(v=shiftStartTime, lty=3)#
#
# write.tree(tree, '~/toytree/tree.tre')#
#
# true params#
# root regime lambda#
b1#
#
# shift regime lambda#
b2#
#
# shift start time (dist from root)#
shiftStartTime#
#
# spanning pair#
t2$tip.label[c(1, length(t2$tip.label))]#
# root regime: 0.02302585#
# shift regime: 0.128755#
# shift start time: 75#
# spanning pair: s1, s25#
#
spanningPairRoot <- t1$tip.label[c(1, length(t1$tip.label))]#
spanningPairShift <- t2$tip.label[c(1, length(t2$tip.label))]#
#
setBAMMpriors(tree, outfile=NULL)#
# ------------------------------------#
#
setwd('~/toytree')#
#
toytree <- read.tree('tree.tre')#
toytree <- ladderize(toytree)#
#
# create bamm object based on true parameters#
true <- as.data.frame(matrix(nrow = 2, ncol = 8)) #
colnames(true) <- c('generation', 'leftchild', 'rightchild', 'abstime', 'lambdainit', 'lambdashift', 'muinit', 'mushift')#
true[, 'generation'] <- 1#
true[, 'abstime'] <- c(0, 75)#
true[, 'lambdainit'] <- c(0.02995732, 0.1360479)#
true[, 'lambdashift'] <- 0#
true[, 'muinit'] <- 0#
true[, 'mushift'] <- 0#
true[, 'leftchild'] <- c('t38', 's1')#
true[, 'rightchild'] <- c('t35', 's30')#
#
trueEd <- getEventData(toytree, true)#
trueTips <- getTipRates(trueEd)$lambda.avg#
#
checkBAMMconvergence(burnin=0.25)#
#
ed <- getEventData(toytree, 'event_data.txt', nsamples=1000, burnin=0.25)#
#
bamm <- getTipRates(ed)$lambda.avg#
dr <- DRstat(toytree)#
tipOrder <- sapply(toytree$tip.label, function(x) which(toytree$edge[,2] == which(toytree$tip.label == x)))#
tipOrder <- names(sort(tipOrder))#
#
trueTips <- trueTips[tipOrder]#
bamm <- bamm[tipOrder]#
dr <- dr[tipOrder]#
#
# shift-specific means#
tipRegimes <- rep(0, length(toytree$tip.label))#
names(tipRegimes) <- tipOrder#
tipRegimes[names(tipRegimes) %in% tips(toytree, getMRCA(toytree, c('s1','s30')))] <- 1#
#
regime0MeanDR <- mean(dr[names(tipRegimes)[which(tipRegimes == 0)]])#
regime1MeanDR <- mean(dr[names(tipRegimes)[which(tipRegimes == 1)]])#
regime0MeanBAMM <- mean(bamm[names(tipRegimes)[which(tipRegimes == 0)]])#
regime1MeanBAMM <- mean(bamm[names(tipRegimes)[which(tipRegimes == 1)]])#
#
# layout(matrix(1:2, nrow=1, ncol=2), widths=c(0.3, 0.7))#
# par(mar = c(5,4,4,0))#
# #plot(trueEd, lwd=1.5)#
# plot.phylo(toytree, show.tip.label = FALSE, edge.width=1.5)#
# addBAMMshifts(trueEd, par.reset=F)#
# par(mar = c(5,0,4,2))#
# plot.new()#
# plot.window(xlim = c(0, 0.3), ylim = c(0, 69))#
# axis(1)#
#
# segments(regime0MeanDR, 31, regime0MeanDR, 69, col='red', lwd=2)#
# segments(regime1MeanDR, 1, regime1MeanDR, 30, col='red', lwd=2)#
# segments(regime0MeanBAMM, 31, regime0MeanBAMM, 69, col='blue', lwd=2)#
# segments(regime1MeanBAMM, 1, regime1MeanBAMM, 30, col='blue', lwd=2)#
#
# points(trueTips, 1:length(toytree$tip.label), pch=20)#
# points(bamm, 1:length(toytree $tip.label), col='blue', pch=8)#
# points(dr, 1:length(toytree $tip.label), col='red', pch=2)#
#
# mtext('speciation rate', side = 1, line = 2.5)#
#
# legend('topright', legend = c('true','BAMM','DR'), fill=c('black', 'blue','red'), bty='n')
pdf('~/Dropbox/tipRatesProject/preliminaryplots/shiftTreeTipRateFig_trueRates.pdf', width=6, height=7)
# other option involving error in rates#
layout(matrix(1:3, nrow=1, ncol=3), widths=c(0.3, 0.35, 0.35))#
par(mar = c(5,4,4,0))#
plot.phylo(toytree, show.tip.label = FALSE, edge.width=1.5)#
addBAMMshifts(trueEd, par.reset=F, bg='orange', cex=2.5)#
par(mar = c(5,0,4,2))#
plot.new()#
plot.window(xlim = c(0, 0.3), ylim = c(0, 69))#
axis(1)#
points(trueTips, 1:length(toytree$tip.label), pch=20)#
lines(trueTips, 1:length(toytree$tip.label), lwd=1)
mtext('speciation rate', side = 1, line = 2.5)
legend(0.15, 69, legend = c(expression(paste(lambda['TRUE'])), expression(paste(lambda['BAMM'])), expression(paste(lambda['DR']))), fill=c('black', 'blue','red'), bty='n', cex=1.5)#
#
plot.new()#
plot.window(xlim = c(0, 0.2), ylim = c(0, 69))#
axis(1)#
segments(abs(bamm - trueTips), 1:length(toytree$tip.label), abs(dr - trueTips), 1:length(toytree$tip.label), lwd=0.5)#
points(abs(bamm - trueTips), 1:length(toytree$tip.label), pch=20, col='blue')#
points(abs(dr - trueTips), 1:length(toytree$tip.label), pch=20, col='red')#
abline(v=0, lty=3)#
#
# add means#
points(mean(abs(bamm - trueTips)), -1, col='blue', pch=8)#
points(mean(abs(dr - trueTips)), -1, col='red', pch=8)#
#
mtext('absolute error', side = 1, line = 2.5)#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/shiftTreeTipRateFig_BAMMRates.pdf', width=6, height=7)
layout(matrix(1:3, nrow=1, ncol=3), widths=c(0.3, 0.35, 0.35))#
par(mar = c(5,4,4,0))#
plot.phylo(toytree, show.tip.label = FALSE, edge.width=1.5)#
addBAMMshifts(trueEd, par.reset=F, bg='orange', cex=2.5)#
par(mar = c(5,0,4,2))#
plot.new()#
plot.window(xlim = c(0, 0.3), ylim = c(0, 69))#
axis(1)#
points(trueTips, 1:length(toytree$tip.label), pch=20)#
lines(trueTips, 1:length(toytree$tip.label), lwd=1)#
points(bamm, 1:length(toytree$tip.label), col='blue', pch=20)#
lines(bamm, 1:length(toytree$tip.label), lwd=0.5, col='blue')
mtext('speciation rate', side = 1, line = 2.5)
legend(0.15, 69, legend = c(expression(paste(lambda['TRUE'])), expression(paste(lambda['BAMM'])), expression(paste(lambda['DR']))), fill=c('black', 'blue','red'), bty='n', cex=1.5)#
#
plot.new()#
plot.window(xlim = c(0, 0.2), ylim = c(0, 69))#
axis(1)#
segments(abs(bamm - trueTips), 1:length(toytree$tip.label), abs(dr - trueTips), 1:length(toytree$tip.label), lwd=0.5)#
points(abs(bamm - trueTips), 1:length(toytree$tip.label), pch=20, col='blue')#
points(abs(dr - trueTips), 1:length(toytree$tip.label), pch=20, col='red')#
abline(v=0, lty=3)#
#
# add means#
points(mean(abs(bamm - trueTips)), -1, col='blue', pch=8)#
points(mean(abs(dr - trueTips)), -1, col='red', pch=8)#
#
mtext('absolute error', side = 1, line = 2.5)#
dev.off()
setwd('~/Dropbox/tipRatesProject/trees/evolvingRates_250')
alltipRates <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
trueTips <- alltipRates[['evolvingRates_250']]$tipLambda#
names(trueTips) <- alltipRates[['evolvingRates_250']]$tipName#
#
tr <- read.tree(grep('\\.tre$', list.files(), value=TRUE))#
tr <- ladderize(tr)#
#
ed <- getEventData(tr, grep('event_data', list.files(), value=TRUE), nsamples=1000, burnin=0.5)#
bamm <- getTipRates(ed)$lambda.avg#
dr <- DRstat(tr)#
#
tipOrder <- sapply(tr$tip.label, function(x) which(tr$edge[,2] == which(tr$tip.label == x)))#
tipOrder <- names(sort(tipOrder))#
#
trueTips <- trueTips[tipOrder]#
bamm <- bamm[tipOrder]#
dr <- dr[tipOrder]
ptsize <- 0.5
pdf('~/Dropbox/tipRatesProject/preliminaryplots/evolvingTreeTipRateFig_trueRates.pdf', width=6, height=7)
layout(matrix(1:3, nrow=1, ncol=3), widths=c(0.3, 0.35, 0.35))#
par(mar = c(5,4,4,0))#
plot.phylo(tr, show.tip.label = FALSE, edge.width=1.5)#
par(mar = c(5,0,4,2))#
plot.new()#
plot.window(xlim = c(0, max(c(max(trueTips), max(bamm), max(dr)))), ylim = c(0, length(tr$tip.label)))#
axis(1)#
points(trueTips, 1:length(tr$tip.label), pch=20, cex= ptsize)#
lines(trueTips, 1:length(tr$tip.label), lwd=1)#
p
legend(0.4, 207, legend = c(expression(paste(lambda['TRUE'])), expression(paste(lambda['BAMM'])), expression(paste(lambda['DR']))), fill=c('black', 'blue','red'), bty='n', cex=1.5)#
#
plot.new()#
plot.window(xlim = c(0, 0.7), ylim = c(0, length(tr$tip.label)))#
axis(1)#
segments(abs(bamm - trueTips), 1:length(tr$tip.label), abs(dr - trueTips), 1:length(tr$tip.label), lwd=0.5)#
points(abs(bamm - trueTips), 1:length(tr$tip.label), pch=20, col='blue', cex= ptsize)#
points(abs(dr - trueTips), 1:length(tr$tip.label), pch=20, col='red', cex= ptsize)#
abline(v=0, lty=3)#
#
# add means#
points(mean(abs(bamm - trueTips)), -5, col='blue', pch=8)#
points(mean(abs(dr - trueTips)), -5, col='red', pch=8)#
mtext('absolute error', side = 1, line = 2.5)#
#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/evolvingTreeTipRateFig_BAMMRates.pdf', width=6, height=7)
layout(matrix(1:3, nrow=1, ncol=3), widths=c(0.3, 0.35, 0.35))#
par(mar = c(5,4,4,0))#
plot.phylo(tr, show.tip.label = FALSE, edge.width=1.5)#
par(mar = c(5,0,4,2))#
plot.new()#
plot.window(xlim = c(0, max(c(max(trueTips), max(bamm), max(dr)))), ylim = c(0, length(tr$tip.label)))#
axis(1)#
points(trueTips, 1:length(tr$tip.label), pch=20, cex= ptsize)#
lines(trueTips, 1:length(tr$tip.label), lwd=1)#
points(bamm, 1:length(tr$tip.label), col='blue', pch=20, cex= ptsize)#
lines(bamm, 1:length(tr$tip.label), lwd=0.5, col='blue')
mtext('speciation rate', side = 1, line = 2.5)
legend(0.4, 207, legend = c(expression(paste(lambda['TRUE'])), expression(paste(lambda['BAMM'])), expression(paste(lambda['DR']))), fill=c('black', 'blue','red'), bty='n', cex=1.5)#
#
plot.new()#
plot.window(xlim = c(0, 0.7), ylim = c(0, length(tr$tip.label)))#
axis(1)#
segments(abs(bamm - trueTips), 1:length(tr$tip.label), abs(dr - trueTips), 1:length(tr$tip.label), lwd=0.5)#
points(abs(bamm - trueTips), 1:length(tr$tip.label), pch=20, col='blue', cex= ptsize)#
points(abs(dr - trueTips), 1:length(tr$tip.label), pch=20, col='red', cex= ptsize)#
abline(v=0, lty=3)#
#
# add means#
points(mean(abs(bamm - trueTips)), -5, col='blue', pch=8)#
points(mean(abs(dr - trueTips)), -5, col='red', pch=8)#
mtext('absolute error', side = 1, line = 2.5)#
#
dev.off()
