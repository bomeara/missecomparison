basepath <- '~/Dropbox/tipRatesProject/trees/'#
treefolders <- list.files(basepath)#
#
outfile <- '~/Dropbox/tipRatesProject/estimatedTipRates_spectralCRBD.csv'#
#
require(ape)#
require(geiger)#
require(BAMMtools)#
require(phangorn)#
require(phytools)#
#
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')#
source('~/Dropbox/tipRatesProject/sourceFxns.R')#
#
tipTableColumns <- c('treeName','setname','tipName', 'lambdaSpectr', 'netDivSpectr')#
#
# reorder treefolders#
treefolders <- treefolders[order(gsub('(.+)_(\\d+)$', '\\1', treefolders), as.numeric(gsub('(.+)_(\\d+)$', '\\2', treefolders)))]#
#
estimRatesList <- vector('list', length(treefolders))#
names(estimRatesList) <- treefolders#
#
skipped <- c()
i<-671
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))
tr
plot(tr)
paste0(basepath, treefolders[i])
tree <- tr
is.ultrametric(tree)
res <- spectR(tree)
system.time(bic <- BICompare(tree, res$eigengap))
BICompare
tree -> phylo
res$eigengap
t <- 1063
kmeansBIC <- function(fit) {#
        m <- ncol(fit$centers)#
        n <- length(fit$cluster)#
        k <- nrow(fit$centers)#
        D <- fit$tot.withinss#
        return(data.frame(BIC = D + log(n) * m * k))#
    }
rDP <- c()#
        r <- c()
i<-1
rDP[[i]] <- as.matrix(dist.nodes(rcoal(n = length(phylo$tip.label),
br = runif(1000, 0, max(branching.times(phylo)/20)))))
r[i] <- kmeansBIC(kmeans(rDP[[i]], t, algorithm = "Hartigan-Wong"))
rDP <- c()#
        r <- c()#
        for (i in c(1:1000)) {#
        	cat(i, '\n')#
            rDP[[i]] <- as.matrix(dist.nodes(rcoal(n = length(phylo$tip.label), #
                br = runif(1000, 0, max(branching.times(phylo)/20)))))#
            r[i] <- kmeansBIC(kmeans(rDP[[i]], t, algorithm = "Hartigan-Wong"))#
        }
rcoal(n = length(phylo$tip.label), #
                br = runif(1000, 0, max(branching.times(phylo)/20)
)
)
length(phylo$tip.label)
max(branching.times(phylo)/20)
rDP[[i]] <- as.matrix(dist.nodes(rcoal(n = length(phylo$tip.label),
br = runif(1000, 0, max(branching.times(phylo)/20)))))
kmeansBIC(kmeans(rDP[[i]], t, algorithm = "Hartigan-Wong")
)
rDP <- c()#
        r <- c()#
        for (i in c(1:1000)) {#
        	cat(i, '\n')#
            rDP[[i]] <- as.matrix(dist.nodes(rcoal(n = length(phylo$tip.label), #
                br = runif(1000, 0, max(branching.times(phylo)/20)))))#
            r[i] <- kmeansBIC(kmeans(rDP[[i]], t, algorithm = "Hartigan-Wong"))#
        }
rDP
r
zDP <- c()#
        pDP <- c()
m = mean(as.numeric(r))
s = sd(as.numeric(r))
m
s
length(r)
j
j<-1
pnorm(as.numeric(r[j]), m, s)
for (j in 1:length(r)) {#
            pDP[[j]] <- 1 - pnorm(as.numeric(r[j]), m, s)#
        }
dim(phyloM)
phyloM <- as.matrix(dist.nodes(phylo))
q <- kmeans(phyloM, t, algorithm = "Hartigan-Wong")
p <- kmeansBIC(q)
rp <- cbind(p, r)
colnames(rp) <- c("tree BIC", "random BIC")
res <- list(BIC_test = rp, clusters = q$cluster, `BSS/TSS` = q$betweenss/q$totss)
res
t
phylo
t
phyloM <- as.matrix(dist.nodes(phylo))
q <- kmeans(phyloM, t, algorithm = "Hartigan-Wong")
q$cluster
?BICompare
res$eigengap
? spectR
? spectR
spectral <- spectR(tree)
spectral$eigengap
phyloM <- as.matrix(dist.nodes(tree))
clus <- kmeans(phyloM, spectral$eigengap, algorithm = "Hartigan-Wong")
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')
i<-1
tipTableColumns <- c('treeName','setname','tipName', 'lambdaSpectr', 'netDivSpectr')#
#
# reorder treefolders#
treefolders <- treefolders[order(gsub('(.+)_(\\d+)$', '\\1', treefolders), as.numeric(gsub('(.+)_(\\d+)$', '\\2', treefolders)))]#
#
estimRatesList <- vector('list', length(treefolders))#
names(estimRatesList) <- treefolders
i
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	cat('\t', length(tr$tip.label), 'tips\n\n')
i<-2
spectral <- try(spectrCRBD(tr))
spectral <- try(spectrCRBD2(tr))
tree <- tr
spectral <- spectR(tree)
phyloM <- as.matrix(dist.nodes(tree))
clus <- kmeans(phyloM, spectral$eigengap, algorithm = "Hartigan-Wong")
terminalNodes <- 1:length(tree$tip.label)#
	tipOrder <- sapply(tree$tip.label, function(x) which(tree$edge[,2] == which(tree$tip.label == x)))#
	tipOrder <- names(sort(tipOrder))
length(unique(clus[terminalNodes]))
modList <- vector('list', length(unique(clus[terminalNodes])))#
	for (i in 1:length(unique(clus[terminalNodes]))) {#
		mod <- unique(clus[terminalNodes])[i]#
		mod <- intersect(terminalNodes, names(which(clus == mod)))#
		modList[[i]] <- tipOrder[as.numeric(mod)]#
	}
clus
names(clus)
clus$cluster
clus <- kmeans(phyloM, spectral$eigengap, algorithm = "Hartigan-Wong")
# identify the modalities that have tips#
	terminalNodes <- 1:length(tree$tip.label)#
	tipOrder <- sapply(tree$tip.label, function(x) which(tree$edge[,2] == which(tree$tip.label == x)))#
	tipOrder <- names(sort(tipOrder))#
	modList <- vector('list', length(unique(clus$cluster[terminalNodes])))#
	for (i in 1:length(unique(clus$cluster[terminalNodes]))) {#
		mod <- unique(clus$cluster[terminalNodes])[i]#
		mod <- intersect(terminalNodes, names(which(clus$cluster == mod)))#
		modList[[i]] <- tipOrder[as.numeric(mod)]#
	}
modList
clus$cluster
spectral$eigengap
spectral <- spectR(tree)
spectral$eigengap
tree
tr
i
i<-2
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	cat('\t', length(tr$tip.label), 'tips\n\n')
tr
tree <- tr
spectral <- spectR(tree)
spectral$eigengap
phyloM <- as.matrix(dist.nodes(tree))
clus <- kmeans(phyloM, spectral$eigengap, algorithm = "Hartigan-Wong")
# identify the modalities that have tips#
	terminalNodes <- 1:length(tree$tip.label)#
	tipOrder <- sapply(tree$tip.label, function(x) which(tree$edge[,2] == which(tree$tip.label == x)))#
	tipOrder <- names(sort(tipOrder))#
	modList <- vector('list', length(unique(clus$cluster[terminalNodes])))#
	for (i in 1:length(unique(clus$cluster[terminalNodes]))) {#
		mod <- unique(clus$cluster[terminalNodes])[i]#
		mod <- intersect(terminalNodes, names(which(clus$cluster == mod)))#
		modList[[i]] <- tipOrder[as.numeric(mod)]#
	}
modList
modNodes <- sort(unlist(sapply(modList, function(x) getMRCA(tree, x))))
# add root regime if it is not already present.#
	if (!(length(tree$tip.label) + 1) %in% modNodes) {#
		modNodes <- c((length(tree$tip.label) + 1), modNodes)#
	}
modNodes <- as.numeric(names(sort(branching.times(tree)[as.character(modNodes)], decreasing=TRUE)))
plot_BICompare(tree, bic)
?plot_BICompare
plot_BICompare
names(bic)
t
t <- max(clus$cluster[[2]])
t <- max(clus$cluster)#
    col_edge <- rainbow(t)[clus$cluster[tree$edge[, 2]]]#
    col_tip <- rainbow(t)[clus$cluster[1:length(tree$tip.label)]]#
    plot(tree, edge.color = col_edge, tip.color = col_tip, type = "fan", cex = 0.4)
nodelabels(text=rep('', length(modNodes)), node=modNodes, frame='circle', cex=0.3)
i<-167
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	cat('\t', length(tr$tip.label), 'tips\n\n')
i<-671
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	cat('\t', length(tr$tip.label), 'tips\n\n')
spectral <- try(spectrCRBD2(tr))
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')
spectral <- try(spectrCRBD2(tr))
spectral
tree <-tr
spectral <- spectR(tree)#
	phyloM <- as.matrix(dist.nodes(tree))#
	clus <- kmeans(phyloM, spectral$eigengap, algorithm = "Hartigan-Wong")
# identify the modalities that have tips#
	terminalNodes <- 1:length(tree$tip.label)#
	tipOrder <- sapply(tree$tip.label, function(x) which(tree$edge[,2] == which(tree$tip.label == x)))#
	tipOrder <- names(sort(tipOrder))#
	modList <- vector('list', length(unique(clus$cluster[terminalNodes])))#
	for (i in 1:length(unique(clus$cluster[terminalNodes]))) {#
		mod <- unique(clus$cluster[terminalNodes])[i]#
		mod <- intersect(terminalNodes, names(which(clus$cluster == mod)))#
		modList[[i]] <- tipOrder[as.numeric(mod)]#
	}
# get mrca of regimes#
	# here, singleton modalities are automatically dropped as the MRCA is NULL.#
	modNodes <- sort(unlist(sapply(modList, function(x) getMRCA(tree, x))))#
	# add root regime if it is not already present.#
	if (!(length(tree$tip.label) + 1) %in% modNodes) {#
		modNodes <- c((length(tree$tip.label) + 1), modNodes)#
	}#
	# sort nodes chronologically#
	modNodes <- as.numeric(names(sort(branching.times(tree)[as.character(modNodes)], decreasing=TRUE)))
tipRates <- list(lambda = rep(NA, length(tree$tip.label)), mu = rep(NA, length(tree$tip.label)))
names(tipRates[[1]]) <- tree$tip.label#
	names(tipRates[[2]]) <- tree$tip.label
head(tipRates[[1]])
for (i in 1:length(modNodes)) {#
		modClade <- extract.clade(tree, modNodes[i])#
		# if lambda is at bounds, increase lmax#
		upperBound <- 10#
		lowerBound <- 0.001#
		bdpars <- fitCRBD(modClade, lmin = lowerBound, lmax = upperBound)#
		while (bdpars[1] == upperBound) {#
			upperBound <- upperBound + 5#
			bdpars <- fitCRBD(tr, lmin = lowerBound, lmax = upperBound)#
		}#
		lambda <- rep(bdpars[1], length(modClade$tip.label))#
		mu <- rep(bdpars[2], length(modClade$tip.label))#
		names(lambda) <- modClade$tip.label#
		names(mu) <- modClade$tip.label#
		tipRates[[1]][names(lambda)] <- lambda#
		tipRates[[2]][names(mu)] <- mu#
	}
tipRates
anyNA(tipRates[[1]])
anyNA(tipRates[[1]]) | anyNA(tipRates[[2]])
?kmeans
