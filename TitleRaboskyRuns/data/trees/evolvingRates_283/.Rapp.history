par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), border='blue')#
	}#
#
}
?par
par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n')#
	}#
#
}
par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
#
}
par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
#
}
par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='u', outline=F)#
	}#
	abline(h=0, lty=3)#
#
}
par(mfrow=c(1,5))#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F, drawRect=F)#
	}#
	abline(h=0, lty=3)#
#
}
?par
tmp <- boxplot(datSplit[[j]][, errorCol], at = j, wex=0.75, plot=F)
tmp
boxplot(datSplit[[j]][, errorCol], plot=F)
tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)
par(mfrow=c(1,5))
i<-1
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
j<-1
tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)
rect(tmp$stats[1,2], tmp$stats[4,2])
tmp$stats[1,2]
tmp
tmp$stats
rect(tmp$stats[1,1], tmp$stats[4,1])
tmp$stats[1,1]
width <- 0.2
rect(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[4,1])
width=0.4
rect(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[4,1])
par(mfrow=c(1,5))
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)
rect(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[4,1], col=gray(0.75))
segments(j, tmp$stats[2,1], j, tmp$stats[4,1], lty=2)
segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)
par(mfrow=c(1,5))
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)
rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))
segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)
segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)
arrows(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2, angle=90, length=0.1)
arrows(j, tmp$stats[2,1], j, tmp$stats[1,1], lty=2, angle=90, length=0.05)
segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])
par(mfrow=c(1,5))
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/2, tmp$stats[4,1], j + width/2, tmp$stats[4,1])
segments(j - width/2, tmp$stats[5,1], j + width/2, tmp$stats[5,1])
segments(j - width/2, tmp$stats[3,1], j + width/2, tmp$stats[3,1], lwd=2)
par(mfrow=c(1,5))
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/2, tmp$stats[5,1], j + width/2, tmp$stats[5,1])#
		segments(j - width/2, tmp$stats[3,1], j + width/2, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
for (j in 1:length(datSplit)) {#
		# tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		# rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		# segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		# segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		# segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		# segments(j - width/2, tmp$stats[5,1], j + width/2, tmp$stats[5,1])#
		# segments(j - width/2, tmp$stats[3,1], j + width/2, tmp$stats[3,1], lwd=2)#
		boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}
abline(h=0, lty=3)
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=1.5)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}
par(mfrow=c(1,5))#
#
width <- 0.4#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
#
}
errorLabel
par(mfrow=c(1,5))#
#
width <- 0.4#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)#
#
}
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)#
#
}
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossRegimeNum_absoluteError2.pdf', width=10, height=3)#
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)#
dev.off()
Lambda <- 0.2#
#
treeList <- vector('list', 100)#
for (i in 1:100) {#
	cat(i, '\n')#
	Eps <- runif(1, 0.5, 1)#
	Mu <- Eps * Lambda#
	treeList[[i]] <- sim.bd.taxa(100, 1, Lambda, Mu, complete=FALSE)[[1]]#
}
require(TreeSim)
Lambda <- 0.2#
#
treeList <- vector('list', 100)#
for (i in 1:100) {#
	cat(i, '\n')#
	Eps <- runif(1, 0.5, 1)#
	Mu <- Eps * Lambda#
	treeList[[i]] <- sim.bd.taxa(100, 1, Lambda, Mu, complete=FALSE)[[1]]#
}
treeList <- vector('list', 100)#
trueparams <- as.data.frame(matrix(nrow=100, ncol = 2))#
colnames(trueparams) <- c('lambda','mu')#
trueparams[,1] <- Lambda
for (i in 1:100) {#
	cat(i, '\n')#
	Eps <- runif(1, 0.5, 1)#
	Mu <- Eps * Lambda#
	treeList[[i]] <- sim.bd.taxa(100, 1, Lambda, Mu, complete=FALSE)[[1]]#
}
trueparams
treeList <- vector('list', 100)#
trueparams <- as.data.frame(matrix(nrow=100, ncol = 2))#
colnames(trueparams) <- c('lambda','mu')#
trueparams[,1] <- Lambda#
#
for (i in 1:100) {#
	cat(i, '\n')#
	Eps <- runif(1, 0.5, 1)#
	Mu <- Eps * Lambda#
	trueparams[i,2] <- Mu#
	treeList[[i]] <- sim.bd.taxa(100, 1, Lambda, Mu, complete=FALSE)[[1]]#
}
trueparams
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')
ls()
dr <- lapply(treeList, function(x) DRstat(x))
meanDR <- sapply(dr, mean)
plot(Lambda - trueparams[,2], meanDR)
plot(Lambda - trueparams[,2], meanDR, xlim = c(0, 0.35), ylim = c(0, 0.35))
require(ppcor)#
require(AICcmodavg)#
#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)
summary(lm(lambdaDR ~ tipLambda, data = regimeSummary))#
summary(lm(lambdaDR ~ tipNetDiv, data = regimeSummary))
fit1 <- lm(lambdaDR ~ tipLambda, data = regimeSummary)#
fit2 <- lm(lambdaDR ~ tipNetDiv, data = regimeSummary)#
#
aictab(list(lambda=fit1, netdiv=fit2))
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')
qq <- do.call(rbind, qq)
qq <- do.call(rbind, allRatesList)
unique(qq$setname)
unique(regimeSummary$setname)
qq <- qq[which(qq$setname %in% unique(regimeSummary$setname)),]
head(qq)
fit1 <- lm(lambdaDR ~ tipLambda, data = qq)
fit2 <- lm(lambdaDR ~ tipNetDiv, data = qq)
aictab(list(lambda=fit1, netdiv=fit2))
summary(fit1)
summary(fit2)
summary(lm(lambdaDR ~ tipLambda + tipNetDiv, data = qq))
# Summarize results by true regime#
## For multi-regime trees, summarize tip rates (true and inferred) by known regimes#
#
outfile <- '~/Dropbox/tipRatesProject/regimeSummary.csv'#
#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# put CRBD table in same order#
ordering <- sapply(names(trueRatesList), function(x) which(crbd$treeName == x))#
crbd <- crbd[ordering,]#
#
# merge the two, and add CRBD lambda and mu (identical values across tip names)#
allRatesList <- vector('list', length = length(trueRatesList))#
names(allRatesList) <- names(trueRatesList)#
for (i in 1:length(trueRatesList)) {#
	allRatesList[[i]] <- cbind.data.frame(trueRatesList[[i]], estimatedRatesList[[i]][, c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM')], CRBDlambda = crbd[i, 'lambda'], CRBDmu = crbd[i, 'mu'])#
}
setvec <- c('MitchellRabosky2016','MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017','highTurnoverBD','LambdaEqualsMu')
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])#
#
regimeList <- list()#
#
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}#
#
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)#
#
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])#
#
write.csv(regimeSummary, outfile, row.names = FALSE)
## Diversity-dependent trees#
outfile <- '~/Dropbox/tipRatesProject/regimeSummary_dd.csv'#
#
setvec <- c('fossilBAMMDD', 'Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')#
#
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])#
#
regimeList <- list()#
#
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}#
#
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)#
#
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])#
#
write.csv(regimeSummary, outfile, row.names = FALSE)
unique(treeDat$setname)
setvec <- c('evolvingRates')
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])
regimeList <- list()
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])
head(regimeSummary)
outfile
outfile <- '~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv'
outfile
write.csv(regimeSummary, outfile, row.names = FALSE)
## Read in datasets#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)
outfile <- '~/Dropbox/tipRatesProject/rateErrorMetrics.csv'
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# put CRBD table in same order#
ordering <- sapply(names(trueRatesList), function(x) which(crbd$treeName == x))#
crbd <- crbd[ordering,]
# merge the two, and add CRBD lambda and mu (identical values across tip names)#
allRatesList <- vector('list', length = length(trueRatesList))#
names(allRatesList) <- names(trueRatesList)#
for (i in 1:length(trueRatesList)) {#
	allRatesList[[i]] <- cbind.data.frame(trueRatesList[[i]], estimatedRatesList[[i]][, c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM')], CRBDlambda = crbd[i, 'lambda'], CRBDmu = crbd[i, 'mu'])#
}
saveRDS(allRatesList, '~/Dropbox/tipRatesProject/allRatesList.rds')
meanAbsoluteError <- function(estimated, true) {#
	mean(estimated - true)#
}#
#
# PROPORTIONAL ERROR METRICS (from Rabosky et al. 2014 appendix)#
#
# estimated = vector of estimated tip values#
# true = true tip values#
#
# overall mean proportional error#
propError1 <- function(estimated, true) {#
	sum((estimated - true) / true) / length(true)#
}#
#
# overall mean proportional errror, weighted by the relative size of the regime#
# regimeVec is a categorical vector of regimeID of the same length as vec estimated and vec true.#
# it should represent the relative size of the regime, to the whole tree#
propError2 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	sum(((estimated - true) / true) * regimeVec)#
}#
#
# mean error over all tips, using log-transformed rates#
propError3 <- function(estimated, true) {#
	exp(sum(log(estimated) - log(true)) / length(true))#
}#
#
# mean error over all tips, using log-transformed rates, where rates are weighted by regime size.#
propError4 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	exp(sum((log(estimated) - log(true)) * regimeVec))#
}#
# ols regression R2 and slope#
olsRegression <- function(estimated, true) {#
	if (!all(is.na(estimated))) {#
		ols <- lm(estimated ~ true)#
		if (nrow(summary(ols)$coefficients) > 1) {#
			setNames(c(summary(ols)$coefficients[2,1], summary(ols)$adj.r.squared), c('slope','r2'))#
		} else {#
			setNames(c(NA, NA), c('slope','r2'))#
		}#
	} else {#
		setNames(c(NA, NA), c('slope','r2'))#
	}#
}
# -----------------------------------------------#
#
# calculate different error metrics between true and estimated rates for each tree#
#
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 6))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# check ordering#
identical(names(allRatesList), dat$treeName)
tipMetricHeaders <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricHeadersNetDiv <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
#
for (i in 1:nrow(dat)) {#
	for (j in 1:length(tipMetricHeaders)) {#
		# speciation rate#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[1]#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[2]#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
		# Net diversification rate#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[1]#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[2]#
#
	dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
	}#
}#
#
head(dat)
# Summarize results by true regime#
## For multi-regime trees, summarize tip rates (true and inferred) by known regimes#
#
outfile <- '~/Dropbox/tipRatesProject/regimeSummary.csv'#
#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# put CRBD table in same order#
ordering <- sapply(names(trueRatesList), function(x) which(crbd$treeName == x))#
crbd <- crbd[ordering,]#
#
# merge the two, and add CRBD lambda and mu (identical values across tip names)#
allRatesList <- vector('list', length = length(trueRatesList))#
names(allRatesList) <- names(trueRatesList)#
for (i in 1:length(trueRatesList)) {#
	allRatesList[[i]] <- cbind.data.frame(trueRatesList[[i]], estimatedRatesList[[i]][, c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM')], CRBDlambda = crbd[i, 'lambda'], CRBDmu = crbd[i, 'mu'])#
}#
# use regime ID to create table of regimes, and true/inferred rate averages#
# single-regime trees will be a single regime#
# also record size of regimes#
#
setvec <- c('MitchellRabosky2016','MeyerWiens2017','fossilBAMM','MooreEtAl2016','RaboskyEtAl2017','highTurnoverBD','LambdaEqualsMu')#
#
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])#
#
regimeList <- list()#
#
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}#
#
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)#
#
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])#
#
write.csv(regimeSummary, outfile, row.names = FALSE)#
## Diversity-dependent trees#
outfile <- '~/Dropbox/tipRatesProject/regimeSummary_dd.csv'#
#
setvec <- c('fossilBAMMDD', 'Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')#
#
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])#
#
regimeList <- list()#
#
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}#
#
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)#
#
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])#
#
write.csv(regimeSummary, outfile, row.names = FALSE)#
## Evolving Rates trees#
#
outfile <- '~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv'#
#
setvec <- c('evolvingRates')#
#
setInd <- unique(treeDat[which(treeDat$setname %in% setvec), 'treeName'])#
#
regimeList <- list()#
#
counter <- 1#
for (i in 1:length(setInd)) {#
	cat(i, 'of', length(setInd), '\n')#
	xx <- allRatesList[[setInd[i]]]#
	# take average of all tip metrics, grouped by regimeID#
	tmp <- aggregate(xx[, colnames(xx)[which(colnames(xx) == 'tipLambda'):ncol(xx)]], list(xx$regimeID), mean)#
	regimeList[[counter]] <- cbind(treeName = xx[1, 'treeName'], setname = xx[1, 'setname'], nTips = aggregate(xx$regimeID, list(xx$regimeID), length)$x, tmp)#
	counter <- counter + 1	#
}#
#
regimeSummary <- do.call(rbind, regimeList)#
regimeSummary <- regimeSummary[, -which(colnames(regimeSummary) == 'Group.1')]#
regimeSummary <- as.data.frame(regimeSummary, stringsAsFactors=FALSE)#
#
for (i in 3:ncol(regimeSummary)) {#
	regimeSummary[, i] <- as.numeric(regimeSummary[, i])#
}#
regimeSummary[,1] <- as.character(regimeSummary[,1])#
regimeSummary[,2] <- as.character(regimeSummary[,2])#
#
write.csv(regimeSummary, outfile, row.names = FALSE)
## Read in datasets#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
outfile <- '~/Dropbox/tipRatesProject/rateErrorMetrics.csv'#
# ----------------------------------------------------#
# Combine true and estimated datasets into one object#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# put CRBD table in same order#
ordering <- sapply(names(trueRatesList), function(x) which(crbd$treeName == x))#
crbd <- crbd[ordering,]#
#
# merge the two, and add CRBD lambda and mu (identical values across tip names)#
allRatesList <- vector('list', length = length(trueRatesList))#
names(allRatesList) <- names(trueRatesList)#
for (i in 1:length(trueRatesList)) {#
	allRatesList[[i]] <- cbind.data.frame(trueRatesList[[i]], estimatedRatesList[[i]][, c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM')], CRBDlambda = crbd[i, 'lambda'], CRBDmu = crbd[i, 'mu'])#
}#
#
saveRDS(allRatesList, '~/Dropbox/tipRatesProject/allRatesList.rds')
meanAbsoluteError <- function(estimated, true) {#
	mean(estimated - true)#
}#
#
# PROPORTIONAL ERROR METRICS (from Rabosky et al. 2014 appendix)#
#
# estimated = vector of estimated tip values#
# true = true tip values#
#
# overall mean proportional error#
propError1 <- function(estimated, true) {#
	sum((estimated - true) / true) / length(true)#
}#
#
# overall mean proportional errror, weighted by the relative size of the regime#
# regimeVec is a categorical vector of regimeID of the same length as vec estimated and vec true.#
# it should represent the relative size of the regime, to the whole tree#
propError2 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	sum(((estimated - true) / true) * regimeVec)#
}#
#
# mean error over all tips, using log-transformed rates#
propError3 <- function(estimated, true) {#
	exp(sum(log(estimated) - log(true)) / length(true))#
}#
#
# mean error over all tips, using log-transformed rates, where rates are weighted by regime size.#
propError4 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	exp(sum((log(estimated) - log(true)) * regimeVec))#
}#
# ols regression R2 and slope#
olsRegression <- function(estimated, true) {#
	if (!all(is.na(estimated))) {#
		ols <- lm(estimated ~ true)#
		if (nrow(summary(ols)$coefficients) > 1) {#
			setNames(c(summary(ols)$coefficients[2,1], summary(ols)$adj.r.squared), c('slope','r2'))#
		} else {#
			setNames(c(NA, NA), c('slope','r2'))#
		}#
	} else {#
		setNames(c(NA, NA), c('slope','r2'))#
	}#
}#
#
# -----------------------------------------------#
#
# calculate different error metrics between true and estimated rates for each tree
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 6))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# check ordering#
identical(names(allRatesList), dat$treeName)#
#
# calculate proportional error of estimated to true true lambda tip rates for each different tip rate metric#
#
tipMetricHeaders <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricHeadersNetDiv <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
#
for (i in 1:nrow(dat)) {#
	for (j in 1:length(tipMetricHeaders)) {#
		# speciation rate#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[1]#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[2]#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
		# Net diversification rate#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[1]#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[2]#
#
	dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
	}#
}#
#
head(dat)
write.csv(dat, outfile, row.names=FALSE)
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
table(dat$setname)
setsToUse <- c('MitchellRabosky2016','RaboskyEtAl2017','fossilBAMMDD','evolvingRates')
plotLabels <- c('single-regime, constant-rate', 'multi-regime, constant-rate', 'single-regime, diversity-dependent', 'continuous rate variation')
i<-4
qq <- dat[which(dat$setname == setsToUse[i]),]
nrow(qqq)
nrow(qq)
par(mfrow=c(2,2))
par(mfrow=c(1,2))
gridVal
gridVal <- 500
plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaDR', side=2, line = 2.5)#
	heatscatterpoints(qq$tipLambda, qq$lambdaDR, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaBAMM', side=2, line = 2.5)	#
	heatscatterpoints(qq$tipLambda, qq$lambdaBAMM, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	mtext(plotLabels[i], line = 1, at=-0.15, xpd=NA)
head(qq)
quantile(qq$tipLambda, c(0.05, 0.95))
gridVal <-50
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates.png', width=5, height=12, units='in', res=300)#
par(mfrow=c(4,2))#
#
for (i in 1:length(setsToUse)) {#
	qq <- dat[which(dat$setname == setsToUse[i]),]#
#
	plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaDR', side=2, line = 2.5)#
	heatscatterpoints(qq$tipLambda, qq$lambdaDR, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaBAMM', side=2, line = 2.5)	#
	heatscatterpoints(qq$tipLambda, qq$lambdaBAMM, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	mtext(plotLabels[i], line = 1, at=-0.15, xpd=NA)#
}#
#
dev.off()
gridVal <- 500
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates.png', width=5, height=12, units='in', res=300)#
par(mfrow=c(4,2))#
#
for (i in 1:length(setsToUse)) {#
	qq <- dat[which(dat$setname == setsToUse[i]),]#
#
	plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaDR', side=2, line = 2.5)#
	heatscatterpoints(qq$tipLambda, qq$lambdaDR, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	plot.new()#
	plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaBAMM', side=2, line = 2.5)	#
	heatscatterpoints(qq$tipLambda, qq$lambdaBAMM, grid= gridVal)#
	abline(a=0, b=1, lty=3)#
	mtext(plotLabels[i], line = 1, at=-0.15, xpd=NA)#
}#
#
dev.off()
i
plot.new()#
	plot.window(xlim = c(0, 1), ylim = c(0, 1))
axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaDR', side=2, line = 2.5)#
	heatscatterpoints(qq$tipLambda, qq$lambdaDR, grid= gridVal)#
	abline(a=0, b=1, lty=3)
plot.new()#
	plot.window(xlim = c(0, 1), ylim = c(0, 1))
axis(1)#
	axis(2)#
	mtext('true lambda', side=1, line = 2.5)#
	mtext('lambdaBAMM', side=2, line = 2.5)	#
	heatscatterpoints(qq$tipLambda, qq$lambdaBAMM, grid= gridVal)#
	abline(a=0, b=1, lty=3)
require(LSD)
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv', stringsAsFactors=FALSE)
regimeSummary <- regimeSummary[which(regimeSummary$nTips >= 10),]
head(regimeSummary)
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')
par(mfrow=c(2,5), mar = c(5,5,1,1))
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip lambda', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipLambda))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)#
	abline(a=0, b=1, lty=3)#
}
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv', stringsAsFactors=FALSE)
range(regimeSummary$nTips)
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByRegime_evolvingRates.pdf', width=15, height=6)#
#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
par(mfrow=c(2,5), mar = c(5,5,1,1))#
#
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip lambda', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipLambda))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)#
	abline(a=0, b=1, lty=3)#
}#
#
tipMetrics <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
#
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip net div', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipNetDiv))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)	#
	abline(a=0, b=1, lty=3)#
}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)#
#
dev.off()
i
j
par(mfrow=c(2,5), mar = c(5,5,1,1))
tipMetrics <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip net div', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipNetDiv))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)	#
	abline(a=0, b=1, lty=3)#
}
i
axisRange <- quantile(c(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)
head(regimeSummary)
## EVOLVING RATES#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv', stringsAsFactors=FALSE)#
#
regimeSummary <- regimeSummary[which(regimeSummary$nTips >= 10),]#
#
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByRegime_evolvingRates.pdf', width=15, height=6)#
#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
par(mfrow=c(2,5), mar = c(5,5,1,1))#
#
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipLambda, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip lambda', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipLambda))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)#
	abline(a=0, b=1, lty=3)#
}#
#
tipMetrics <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
#
for (i in 1:length(tipMetrics)) {#
	axisRange <- quantile(c(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]]), c(0.01, 0.99), na.rm=TRUE)#
	plot.new()#
	plot.window(xlim = axisRange, ylim = axisRange)#
	axis(1)#
	axis(2)#
	heatscatterpoints(regimeSummary$tipNetDiv, regimeSummary[, tipMetrics[i]], grid = 1000)#
	mtext('true tip net div', side = 1, line = 2, cex=0.7)#
	mtext(tipMetrics[i], side = 2, line = 2, cex=0.7)#
	r2 <- summary(lm(regimeSummary[, tipMetrics[i]] ~ regimeSummary$tipNetDiv))$adj.r.squared#
	text(x=0, y=axisRange[2], paste0('r2 = ',round(r2, 2)), pos=4, xpd=NA)	#
	abline(a=0, b=1, lty=3)#
}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)#
#
dev.off()
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
#
# set infinite values to NA#
for (i in 6:ncol(dat)) {#
	if (length(which(!is.finite(dat[,i]))) > 0) {#
		dat[which(!is.finite(dat[,i])), i] <- NA#
	}#
}#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Different error metrics summarized across regime count#
#
# plot quantile range, and median of error between true lambda tip and different tip rate metrics, in relation to the number of regimes#
#
# error metrics are PE1, PE2, PE3, PE4, r2, slope and absoluteError#
# rateType can be tipLambda or tipNetDiv#
#
plotMetricsAgainstRegimeCount <- function(datSplit, errorMetric, yrange = NULL, qrange = c(0.25, 0.75), rateType='tipLambda', plotTitle) {#
#
	rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
	errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
	errorLabel <- errorMetricNames[errorMetric]#
	# minQ <- 0.25#
	# maxQ <- 0.75#
	minQ <- qrange[1]#
	maxQ <- qrange[2]#
#
	if (any(is.null(yrange))) {#
		minmaxVals <- list(c(), c())#
		for (i in 1:length(rateMetrics)) {#
			ind <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
			minmaxVals[[1]][i] <- min(sapply(datSplit, function(x) quantile(x[, ind], minQ, na.rm=TRUE)), na.rm=TRUE)#
			minmaxVals[[2]][i] <- max(sapply(datSplit, function(x) quantile(x[, ind], maxQ, na.rm=TRUE)), na.rm=TRUE)#
		}#
		yrange <- c(min(minmaxVals[[1]]), max(minmaxVals[[2]]))#
	}#
	par(mfrow=c(1,5))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = yrange)#
		axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
		axis(2)#
		segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, errorCol], minQ, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, errorCol], maxQ, na.rm=TRUE)))#
		points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, errorCol], na.rm=TRUE)), pch=20, cex=0.8)#
		mtext('nRegimes', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetric %in% c('PE1','PE2', 'absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4', 'slope', 'r2')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	mtext(plotTitle, outer=TRUE, line = -2)#
}
# Evolving Rates#
## examine error as a function of sigma#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)
par(mfrow=c(1,5), xpd=NA)#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
errorMetric <- 'absoluteError'
rateType <- 'Lambda'
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,3), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}
rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,3), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)
i
i<-1
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,3), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}
par(mfrow=c(1,5), xpd=NA)#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
errorMetric <- 'absoluteError'#
rateType <- 'Lambda'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0,3), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
errorMetric <- 'absoluteError'#
rateType <- 'Lambda'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)
par(xpd=F)
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.15, 0.15)#
errorMetric <- 'absoluteError'#
rateType <- 'Lambda'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.2, 0.2)#
errorMetric <- 'absoluteError'#
rateType <- 'Lambda'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('evolving rates', outer=TRUE, line = -2)
pdf('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossSigma_absoluteError.pdf', width=10, height=3)#
par(mfrow=c(1,5))#
#
width <- 0.4#
yrange <- c(-0.2, 0.2)#
errorMetric <- 'absoluteError'#
rateType <- 'Lambda'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = 1:3, labels = names(datSplit))#
	axis(2)#
	for (j in 1:length(datSplit)) {#
		tmp <- boxplot(datSplit[[j]][, errorCol], plot=F)#
		rect(j - width/2, tmp$stats[2,1], j + width/2, tmp$stats[4,1], col=gray(0.75))#
		segments(j, tmp$stats[1,1], j, tmp$stats[2,1], lty=2)#
		segments(j, tmp$stats[4,1], j, tmp$stats[5,1], lty=2)#
		segments(j - width/2, tmp$stats[1,1], j + width/2, tmp$stats[1,1])#
		segments(j - width/3, tmp$stats[5,1], j + width/3, tmp$stats[5,1])#
		segments(j - width/3, tmp$stats[3,1], j + width/3, tmp$stats[3,1], lwd=2)#
		# boxplot(datSplit[[j]][, errorCol], at = j, add=TRUE, wex=0.75, col=gray(0.8), bty='n', outline=F)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
}#
mtext('evolving rates', outer=TRUE, line = -2)#
dev.off()
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv', stringsAsFactors=FALSE)
require(ppcor)#
require(AICcmodavg)
summary(lm(lambdaDR ~ tipLambda, data = regimeSummary))
summary(lm(lambdaDR ~ tipNetDiv, data = regimeSummary))
summary(lm(lambdaDR ~ tipLambda + tipNetDiv, data = regimeSummary))
summary(lm(lambdaDR ~ tipLambda * tipNetDiv, data = regimeSummary))
spcor(regimeSummary[,c('lambdaDR','tipLambda','tipNetDiv')])$estimate
spcor(regimeSummary[,c('lambdaDR','tipLambda','tipNetDiv')])$p.value
fit1 <- lm(lambdaDR ~ tipLambda, data = regimeSummary)
fit2 <- lm(lambdaDR ~ tipNetDiv, data = regimeSummary)
aictab(list(lambda=fit1, netdiv=fit2))
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')
qq <- do.call(rbind, allRatesList)
qq <- qq[which(qq$setname %in% unique(regimeSummary$setname)),]
head(qq)
fit1 <- lm(lambdaDR ~ tipLambda, data = qq)
fit2 <- lm(lambdaDR ~ tipNetDiv, data = qq)
aictab(list(lambda=fit1, netdiv=fit2))
summary(lm(lambdaDR ~ tipLambda + tipNetDiv, data = qq))
spcor(qq[,c('lambdaDR','tipLambda','tipNetDiv')])$estimate
require(ppcor)#
require(AICcmodavg)
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary_evolvingRates.csv', stringsAsFactors=FALSE)
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
qq <- do.call(rbind, allRatesList)#
qq <- qq[which(qq$setname %in% unique(regimeSummary$setname)),]
fit1 <- lm(lambdaDR ~ tipLambda, data = qq)
fit2 <- lm(lambdaDR ~ tipNetDiv, data = qq)
aictab(list(lambda=fit1, netdiv=fit2))
summary(fit1)
summary(fit2)
summary(lm(lambdaDR ~ tipLambda, data = qq))
summary(lm(lambdaBAMM ~ tipLambda, data = qq))
head(regimeSummary)
range(regimeSummary$nTips)
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)
dat2 <- dat[which(dat$setname %in% c('evolvingRates')),]
head(dat2)
errorMetricOptions <- c('PE1','PE2','PE3','PE4','r2','slope', 'absoluteError')#
#
rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute')
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-50, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
j<-7
errorLabel <- errorMetricNames[errorMetricOptions[j]]
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))
for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		#yrange <- quantile(dat2[,errorCol], c(0.05, 0.95), na.rm=T)#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (!is.finite(yrange[2])) {#
			yrange[2] <- quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T)#
		}#
		if (j == 5) yrange <- c(0,1)#
		plot.new()#
		plot.window(xlim = range(dat2$nTips), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(dat2$nTips, dat2[,errorCol], cex=0.25)#
		mtext('tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
head(dat2)
q1 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaDR_absoluteError']
q2 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaBAMM_absoluteError']
plot(q1, q2)
q1
mean(a1)
mean(q1)
mean(q2)
median(q1)
median(q2)
q1 <- dat2[which(dat2$nTips <= 50), 'tipLambda_lambdaDR_absoluteError']
q2 <- dat2[which(dat2$nTips <= 50), 'tipLambda_lambdaBAMM_absoluteError']
median(q1)
median(q2)
plot(density(q1))
plot(density(q1), xlim = c(-0.3,0.3))
polygon(density(q2))
plot(density(q1), xlim = c(-0.3,0.3))
lines(density(q2))
q1 <- dat2[which(dat2$nTips <= 100), 'tipLambda_lambdaDR_absoluteError']#
#
q2 <- dat2[which(dat2$nTips <= 100), 'tipLambda_lambdaBAMM_absoluteError']#
plot(density(q1), xlim = c(-0.3,0.3))#
lines(density(q2))
q1 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaDR_absoluteError']#
#
q2 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaBAMM_absoluteError']#
plot(density(q1), xlim = c(-0.3,0.3))#
lines(density(q2))
q1 <- dat2[which(dat2$nTips <= 15), 'tipLambda_lambdaDR_absoluteError']#
#
q2 <- dat2[which(dat2$nTips <= 15), 'tipLambda_lambdaBAMM_absoluteError']#
plot(density(q1), xlim = c(-0.3,0.3))#
lines(density(q2))
q1 <- dat2[which(dat2$nTips <= 15), 'tipLambda_lambdaDR_absoluteError']
q1
min(dat2$nTips)
q1 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaDR_absoluteError']#
#
q2 <- dat2[which(dat2$nTips <= 25), 'tipLambda_lambdaBAMM_absoluteError']#
plot(density(q1), xlim = c(-0.3,0.3))#
lines(density(q2))
plot(density(q1), xlim = c(-0.3,0.3), col='blue')#
lines(density(q2), col='red')
abline(v=0, lty=3)
basepath <- '~/Dropbox/tipRatesProject/trees/'#
treefolders <- list.files(basepath)#
require(BAMMtools)#
#
# reorder treefolders#
treefolders <- treefolders[order(gsub('(.+)_(\\d+)$', '\\1', treefolders), as.numeric(gsub('(.+)_(\\d+)$', '\\2', treefolders)))]#
#
treefolders <- grep('evolvingRates', treefolders, value=T)#
#
coreShifts <- numeric(1200)
for (i in 1:length(treefolders)) {#
	cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	#tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	#ed <- getEventData(tr, grep('event_data.txt|event_out.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
	coreShifts[i] <- stepBF(computeBayesFactors(grep('mcmc_out', files, value=TRUE), expectedNumberOfShifts=1, burnin=0.5), step.size=1, expectedNumberOfShifts=1)$bestModel#
}
coreShifts <- numeric(1200)#
#
for (i in 1:length(treefolders)) {#
	cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()#
	#tr <- read.tree(grep('\\.tre$', files, value = TRUE))#
	#ed <- getEventData(tr, grep('event_data.txt|event_out.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
	coreShifts[i] <- stepBF(computeBayesFactors(grep('mcmc_out', files, value=TRUE), expectedNumberOfShifts=1, burnin=0.5), step.size=1, expectedNumberOfShifts=1)$bestModel#
}
