log(1) - log(0.25)
log(4) - log(1)
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error of lambda and lambda - mu against eps#
# first for single regime trees#
# keep only single regime trees#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
dat2 <- dat2[which(dat2$nRegimes == 1),]#
#
# get true extinction rate for 1 regime trees#
tmp <- treeDat[which(treeDat$treeName %in% dat2$treeName),]#
epsVec <- setNames(tmp$mu0 / tmp$lambda0, tmp$treeName)#
epsVec <- epsVec[dat2$treeName]#
#
# keep only trees with epsilon between 0 and 1#
dat2 <- dat2[which(epsVec <= 1),]#
epsVec <- epsVec[which(epsVec <= 1)]#
#
tipMetrics <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
head(dat2)
cor.test(dat2$tipNetDiv, epsVec, method='spearman')
nrow(dat2)
length(epsVec)
epsVec
dat2$tipNetDiv
head(dat2)
qq <- treeDat[which(treeDat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD')),]
eps <- qq$mu0 / qq$lambda0
head(qq)
plot(qq$lambda0 - qq$mu0, eps)
plot(eps, qq$lambda0 - qq$mu0)
plot(eps, qq$lambda0 - qq$mu0, xlim=c(0,1))
# show that correlation between lambda and net div decreases as epsilon goes up#
qq <- treeDat[which(treeDat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD')),]#
#
eps <- qq$mu0 / qq$lambda0#
#
int <- seq(0, 1, by = 0.01)#
#
rho <- numeric(length(int))#
pval <- numeric(length(int))#
for (i in 1:length(int)) {#
	z <- which(eps >= int[i])#
	rho[i] <- cor.test(qq$lambda0[z], qq$lambda0[z] - qq$mu0[z], method='spearman')$estimate#
	pval[i] <- cor.test(qq$lambda0[z], qq$lambda0[z] - qq$mu0[z], method='spearman')$p.value#
}#
#
par(mfrow=c(2,1))#
plot(int, rho, cex=0.2, type='l', ylim = c(-0.2,1), xlab = 'minimum relative extinction')#
abline(h=0.05, lty=3)#
plot(int, pval, type='l', cex=0.2, ylim = c(0, 0.5), xlab = 'minimum relative extinction')#
abline(h=0.05, lty=3)
require(TreeSim)
?sim.bd.taxa
i
i<-1
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0.05, 0.3)
runif(1, 0.05, 0.3)
runif(1, 0.05, 0.3)
sim.bd.taxa(100, 1, lambda=Lambda, mu=Mu, complete=FALSE)[[1]]
Lambda <- runif(1, 0.05, 0.3)#
	Eps <- runif(1, 0, 1)#
	Mu <- Eps * Lambda
sim.bd.taxa(100, 1, lambda=Lambda, mu=Mu, complete=FALSE)[[1]]
c(Lambda, Mu, Eps)
set1Trees <- vector('list', 1000)#
set1params <- matrix(nrow=1000, ncol=3)#
colnames(set1params) <- c('lambda','mu','eps')#
for (i in 1:1000) {#
	Lambda <- runif(1, 0.05, 0.3)#
	Eps <- runif(1, 0, 1)#
	Mu <- Eps * Lambda#
	set1params[i, ] <- c(Lambda, Mu, Eps)#
	set1Trees[[i]] <- sim.bd.taxa(100, 1, lambda=Lambda, mu=Mu, complete=FALSE)[[1]]#
}
head(set1Trees)
plot(set1Trees[[10]])
head(set1params)
tail(set1params)
NetDiv <- runif(1, 0.05, 0.3)
NetDiv
Eps <- runif(1, 0, 1)
Eps
NetDiv <- runif(1, 0.05, 0.3)#
	Eps <- runif(1, 0, 1)#
	Mu <- runif(1, 0, 0.5)
NetDiv
Eps
Mu
NetDiv <- runif(1, 0.05, 0.3)
Eps <- runif(1, 0, 1)
NetDiv
Eps
Lambda <- NetDiv / (1 - Eps)
Lambda
Mu <- Eps * Lambda
Mu
Lambda - Mu == NetDiv
Mu / Lambda == Eps
cat(i, '\n')#
	NetDiv <- runif(1, 0.05, 0.3)#
	Eps <- runif(1, 0, 1)#
	Lambda <- NetDiv / (1 - Eps)#
	Mu <- Eps * Lambda
c(Lambda, Mu, Eps)
set2Trees <- vector('list', 1000)#
set2params <- matrix(nrow=1000, ncol=3)#
colnames(set2params) <- c('lambda','mu','eps')#
for (i in 1:1000) {	#
	cat(i, '\n')#
	NetDiv <- runif(1, 0.05, 0.3)#
	Eps <- runif(1, 0, 1)#
	Lambda <- NetDiv / (1 - Eps)#
	Mu <- Eps * Lambda#
	set2params[i, ] <- c(Lambda, Mu, Eps)#
	set2Trees[[i]] <- sim.bd.taxa(100, 1, lambda=Lambda, mu=Mu, complete=FALSE)[[1]]#
}
saveRDS(list(list(set1Trees, set1params), list(set2Trees, set2params)), '~/Dropbox/tipRatesProject/netDivSims.rds')
set1params <- as.data.frame(set1params)
set2params <- as.data.frame(set2params)
saveRDS(list(list(set1Trees, set1params), list(set2Trees, set2params)), '~/Dropbox/tipRatesProject/netDivSims.rds')
set1params$netdiv <- set1params$lambda - set1params$mu#
set2params$netdiv <- set2params$lambda - set2params$mu
head(set1params)
head(set2params)
set1params$eps == set1params$mu / set1params$lambda
all(set1params$eps == set1params$mu / set1params$lambda)
set1params[2,'eps']
set1params[2,'mu'] / set1params[2,'lambda']
set1params[2,'eps'] == set1params[2,'mu'] / set1params[2,'lambda']
set1params[2,'eps'] - (set1params[2,'mu'] / set1params[2,'lambda'])
plot(set1params$netdiv, set1params$eps)
plot(set1params$lambda, set1params$eps)
plot(set1params$netdiv, set1params$eps)
plot(set2params$netdiv, set2params$eps)
par(mfrow=c(2,2))#
plot(set1params$eps, set1params$netdiv, xlab = 'eps', ylab = 'net div', title = 'set 1 net div')#
plot(set1params$eps, set1params$lambda, xlab = 'eps', ylab = 'lambda', title = 'set 1 lambda')#
#
plot(set2params$eps, set2params$netdiv, xlab = 'eps', ylab = 'net div', title = 'set 2 net div')#
plot(set2params$eps, set2params$lambda, xlab = 'eps', ylab = 'lambda', title = 'set 2 lambda')
par(mfrow=c(2,2))#
plot(set1params$eps, set1params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 1 net div')#
plot(set1params$eps, set1params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 1 lambda')#
#
plot(set2params$eps, set2params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 2 net div')#
plot(set2params$eps, set2params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 2 lambda', ylim=c(0,5))
warnings()
?plot
par(mfrow=c(2,2))
plot(set1params$eps, set1params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 1 net div')
plot(set1params$eps, set1params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 1 lambda')
plot(set2params$eps, set2params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 2 net div')
plot(set2params$eps, set2params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 2 lambda', ylim=c(0,5))
par(mfrow=c(2,2))#
plot(set1params$eps, set1params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 1 net div')#
plot(set1params$eps, set1params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 1 lambda')#
#
plot(set2params$eps, set2params$netdiv, xlab = 'eps', ylab = 'net div', main = 'set 2 net div')#
plot(set2params$eps, set2params$lambda, xlab = 'eps', ylab = 'lambda', main = 'set 2 lambda', ylim=c(0,10))
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')
set1DR <- lapply(set1trees, DRstat)
set1DR <- lapply(set1Trees, DRstat)
set2DR <- lapply(set2Trees, DRstat)
PE_set1 <- numeric(1000)#
PE_set2 <- numeric(1000)
absoluteError <- function(estimated, true) {#
	mean(abs(estimated - true))#
}#
#
propError1 <- function(estimated, true) {#
	sum((estimated - true) / true) / length(true)#
}
i<-1
colnames(PE) <- c('lambdaAE_set1','netdivAE_set1', 'lambdaPE_set1','netdivPE_set1', 'lambdaAE_set2','netdivAE_set2', 'lambdaPE_set2','netdivPE_set2')
PE <- as.data.frame(matrix(nrow=1000, ncol=4))#
colnames(PE) <- c('lambdaAE_set1','netdivAE_set1', 'lambdaPE_set1','netdivPE_set1', 'lambdaAE_set2','netdivAE_set2', 'lambdaPE_set2','netdivPE_set2')
PE <- as.data.frame(matrix(nrow=1000, ncol=8))
colnames(PE) <- c('lambdaAE_set1','netdivAE_set1', 'lambdaPE_set1','netdivPE_set1', 'lambdaAE_set2', 'netdivAE_set2', 'lambdaPE_set2', 'netdivPE_set2')
set1DR[[i]]
absoluteError(set1DR[[i]], set1params$lambda)
absoluteError(set1DR[[i]], rep(set1params$lambda, 100))
absoluteError(set1DR[[i]], set1params$netdiv)
propError1(set1DR[[i]], set1params$lambda)
propError1(set1DR[[i]], rep(set1params$lambda, 100))
estimated <- set1DR[[i]]
true <- set1$params$lambda[i]
true <- set1params$lambda[i]
true
propError1(set1DR[[i]], set1params$lambda[i])
propError1(set1DR[[i]], rep(set1params$lambda[i], 100))
propError1(set1DR[[i]], rep(set1params$lambda[i], 100))
absoluteError(set1DR[[i]], set1params$lambda[i])
absoluteError(set1DR[[i]], rep(set1params$lambda[i], 100))
propError1(set1DR[[i]], rep(set1params$netdiv[i], 100))
for (i in 1:1000) {#
	# set 1: absolute error in lambda#
	errorTable[i, 'lambdaAE_set1'] <- absoluteError(set1DR[[i]], set1params$lambda[i])#
	# set 1: absolute error in net div#
	errorTable[i, 'netdivAE_set1'] <- absoluteError(set1DR[[i]], set1params$netdiv[i])#
#
	# set 1: proportional error in lambda#
	errorTable[i, 'lambdaPE_set1'] <- propError1(set1DR[[i]], rep(set1params$lambda[i], 100))#
	# set 1: proportional error in net div#
	errorTable[i, 'netdivPE_set1'] <- propError1(set1DR[[i]], rep(set1params$netdiv[i], 100))#
	# set 2: absolute error in lambda#
	errorTable[i, 'lambdaAE_set2'] <- absoluteError(set2DR[[i]], set2params$lambda[i])#
	# set 2: absolute error in net div#
	errorTable[i, 'netdivAE_set2'] <- absoluteError(set2DR[[i]], set2params$netdiv[i])#
#
	# set 2: proportional error in lambda#
	errorTable[i, 'lambdaPE_set2'] <- propError1(set2DR[[i]], rep(set2params$lambda[i], 100))#
	# set 2: proportional error in net div#
	errorTable[i, 'netdivPE_set2'] <- propError1(set2DR[[i]], rep(set2params$netdiv[i], 100))#
#
}
errorTable <- as.data.frame(matrix(nrow=1000, ncol=8))#
colnames(errorTable) <- c('lambdaAE_set1','netdivAE_set1', 'lambdaPE_set1','netdivPE_set1', 'lambdaAE_set2', 'netdivAE_set2', 'lambdaPE_set2', 'netdivPE_set2')
for (i in 1:1000) {#
	# set 1: absolute error in lambda#
	errorTable[i, 'lambdaAE_set1'] <- absoluteError(set1DR[[i]], set1params$lambda[i])#
	# set 1: absolute error in net div#
	errorTable[i, 'netdivAE_set1'] <- absoluteError(set1DR[[i]], set1params$netdiv[i])#
#
	# set 1: proportional error in lambda#
	errorTable[i, 'lambdaPE_set1'] <- propError1(set1DR[[i]], rep(set1params$lambda[i], 100))#
	# set 1: proportional error in net div#
	errorTable[i, 'netdivPE_set1'] <- propError1(set1DR[[i]], rep(set1params$netdiv[i], 100))#
	# set 2: absolute error in lambda#
	errorTable[i, 'lambdaAE_set2'] <- absoluteError(set2DR[[i]], set2params$lambda[i])#
	# set 2: absolute error in net div#
	errorTable[i, 'netdivAE_set2'] <- absoluteError(set2DR[[i]], set2params$netdiv[i])#
#
	# set 2: proportional error in lambda#
	errorTable[i, 'lambdaPE_set2'] <- propError1(set2DR[[i]], rep(set2params$lambda[i], 100))#
	# set 2: proportional error in net div#
	errorTable[i, 'netdivPE_set2'] <- propError1(set2DR[[i]], rep(set2params$netdiv[i], 100))#
#
}
head(errorTable)
par(mfrow=c(1,2))
plot(setparams$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda')
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda')
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'mu')
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(a=0, b=1, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2)#
abline(a=0, b=1, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2)#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylab=c(-1,1))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-1,1))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-10,10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim=c(-10,10))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-10,10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))
plot(set1params$eps, errorTable$lambdaAE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)
abline(h=0, lty=3)
plot(set2params$eps, errorTable$netdivAE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2)
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# mean absolute error in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaAE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim = c(0, 10))#
abline(h=0, lty=3)#
#
# mean absolute error in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivAE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim = c(0, 10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# mean absolute error in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaAE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim = c(0, 5))#
abline(h=0, lty=3)#
#
# mean absolute error in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivAE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim = c(0, 5))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1), xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2), xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2)#
abline(h=0, lty=3)
log(errorTable$lambdaPE_set1)
errorTable$lambdaPE_set1
range(errorTable$lambdaPE_set1)
range(errorTable$netdivPE_set2)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1 + 1), xlab = 'eps', ylab = 'log PE', main = 'lambda', cex=0.2)#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2 + 1), xlab = 'eps', ylab = 'log PE', main = 'netdiv', cex=0.2)#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1 + 1), xlab = 'eps', ylab = 'log PE', main = 'lambda', cex=0.2, ylim = c(-1,1))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2 + 1), xlab = 'eps', ylab = 'log PE', main = 'netdiv', cex=0.2, ylim = c(-1,1))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1 + 1), xlab = 'eps', ylab = 'log PE', main = 'lambda', cex=0.2, ylim = c(-5,5))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2 + 1), xlab = 'eps', ylab = 'log PE', main = 'netdiv', cex=0.2, ylim = c(-5,5))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1 + 1), xlab = 'eps', ylab = 'log PE', main = 'lambda', cex=0.2, ylim = c(-4,4))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2 + 1), xlab = 'eps', ylab = 'log PE', main = 'netdiv', cex=0.2, ylim = c(-4,4))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# mean absolute error in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaAE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim = c(0, 5))#
abline(h=0, lty=3)#
#
# mean absolute error in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivAE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim = c(0, 5))
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# mean absolute error in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaAE_set1, xlab = 'eps', ylab = 'mean absolute error', main = 'lambda', cex=0.2, ylim = c(0, 5))#
abline(h=0, lty=3)#
#
# mean absolute error in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivAE_set2, xlab = 'eps', ylab = 'mean absolute error', main = 'netdiv', cex=0.2, ylim = c(0, 5))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, errorTable$lambdaPE_set1, xlab = 'eps', ylab = 'PE', main = 'lambda', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, errorTable$netdivPE_set2, xlab = 'eps', ylab = 'PE', main = 'netdiv', cex=0.2, ylim=c(-5,10))#
abline(h=0, lty=3)
par(mfrow=c(1,2))#
#
# PE in lambda, where lambda and eps are drawn from independent distributions (set 1)#
plot(set1params$eps, log(errorTable$lambdaPE_set1 + 1), xlab = 'eps', ylab = 'log PE', main = 'lambda', cex=0.2, ylim = c(-4,4))#
abline(h=0, lty=3)#
#
# PE in net div, where net div and eps are drawn from independent distributions (set 2)#
plot(set2params$eps, log(errorTable$netdivPE_set2 + 1), xlab = 'eps', ylab = 'log PE', main = 'netdiv', cex=0.2, ylim = c(-4,4))#
abline(h=0, lty=3)
log(0)
log(0+1)
head(set1params)
max(set1params$eps)
which.max(set1params$eps)
set1params[911,]
which(set1params$eps > 0.99)
which(set2params$eps > 0.99)
which(set1params$eps > 0.95)
write.csv(set1params, '~/Dropbox/tipRatesProject/simulations/constantVariance/set1params.csv', row.names=FALSE)
write.csv(set2params, '~/Dropbox/tipRatesProject/simulations/constantVariance/set2params.csv', row.names=FALSE)
class(set1Trees) <- 'multiPhylo'
class(set2Trees) <- 'multiPhylo'
write.tree(set1Trees, '~/Dropbox/tipRatesProject/simulations/constantVariance/set1Trees.tre')
write.tree(set2Trees, '~/Dropbox/tipRatesProject/simulations/constantVariance/set2Trees.tre')
set1
set1name
setname1
setname1 <- 'lambdaConstantVariance'#
setname2 <- 'netDivConstantVariance'
setwd(paste0(basepath, 'simulations/constantVariance'))
length(set1Trees)
path <- paste0(destinationDir, paste0(setname1, "_", i))
destinationDir <- '~/Dropbox/tipRatesProject/trees/'
writeFiles <- TRUE
writeFiles
path <- paste0(destinationDir, paste0(setname1, "_", i))
path
i
i<-1
path
path <- paste0(destinationDir, paste0(setname1, "_", i))
path
!file.exists(path)
set1Trees[[i]]
paste0(path, "/", setname1, "_", i, ".tre")
for (i in 1:length(set1Trees))#
		path <- paste0(destinationDir, paste0(setname1, "_", i))#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(set1Trees[[i]], paste0(path, "/", setname1, "_", i, ".tre"))#
	}
for (i in 1:length(set1Trees)) {#
		path <- paste0(destinationDir, paste0(setname1, "_", i))#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(set1Trees[[i]], paste0(path, "/", setname1, "_", i, ".tre"))#
	}
i<-1
path <- paste0(destinationDir, paste0(setname2, "_", i))
path
set2Trees[[i]]
paste0(path, "/", setname2, "_", i, ".tre")
for (i in 1:length(set2Trees)) {#
		path <- paste0(destinationDir, paste0(setname2, "_", i))#
		if (!file.exists(path)) {#
			dir.create(path)#
		}#
		write.tree(set2Trees[[i]], paste0(path, "/", setname2, "_", i, ".tre"))#
	}
require(BAMMtools)
i<-1
options(scipen=999)
setwd(paste0(destinationDir, setname1, '_', i))
treename <- paste0(setname1, '_', i, '.tre')
treename
tree <- read.tree(treename)
tree
priors <- setBAMMpriors(tree, outfile = NULL)
priors
priors <- round(priors, 4)
priors
gsub('\\.tre', '', treename)
for (i in 1:1000) {#
#
	setwd(paste0(destinationDir, setname1, '_', i))#
	treename <- paste0(setname1, '_', i, '.tre')#
	tree <- read.tree(treename)#
	priors <- setBAMMpriors(tree, outfile = NULL)#
	priors <- round(priors, 4)#
	#write control file#
	generateControlFile(file = 'divcontrol.txt', params = list(#
			treefile = treename,#
			globalSamplingFraction = 1,#
			numberOfGenerations = 20000000,#
			overwrite = '1',#
			lambdaInitPrior = priors['lambdaInitPrior'],#
			lambdaShiftPrior = priors['lambdaShiftPrior'],#
			muInitPrior = priors['muInitPrior'],#
			expectedNumberOfShifts = '1', #
			numberOfChains = '1',#
			minCladeSizeForShift = 1,#
			outName = gsub('\\.tre', '', treename)))#
}
for (i in 1:1000) {#
#
	setwd(paste0(destinationDir, setname2, '_', i))#
	treename <- paste0(setname2, '_', i, '.tre')#
	tree <- read.tree(treename)#
	priors <- setBAMMpriors(tree, outfile = NULL)#
	priors <- round(priors, 4)#
	#write control file#
	generateControlFile(file = 'divcontrol.txt', params = list(#
			treefile = treename,#
			globalSamplingFraction = 1,#
			numberOfGenerations = 20000000,#
			overwrite = '1',#
			lambdaInitPrior = priors['lambdaInitPrior'],#
			lambdaShiftPrior = priors['lambdaShiftPrior'],#
			muInitPrior = priors['muInitPrior'],#
			expectedNumberOfShifts = '1', #
			numberOfChains = '1',#
			minCladeSizeForShift = 1,#
			outName = gsub('\\.tre', '', treename)))#
}
