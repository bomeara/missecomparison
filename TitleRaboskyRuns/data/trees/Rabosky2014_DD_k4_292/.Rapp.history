i<-1
tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]
tmp
i<-3000
tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]
tmp
head(treeDat)
tmp <- split(treeDat, treeDat$treeName)
tmp <- tmp[which(sapply(tmp, nrow) == 1)]
length(tmp)
head(tmp)
tmp <- do.call(rbind, tmp)
muTable <- cbind.data.frame(tmp$treeName, tmp$mu0)
head(muTable)
head(tmp)
str(muTable)
muVec <- setNames(tmp$mu0, tmp$treeName)
head(muVec)
muVec <- muVec[datSplit[[1]]$treeName]
head(datSplit[[1]])
head(muVec)
nrow(datSplit[[1]])
length(muVec)
unique(datSplit[[1]]$setname)
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
# just 1 regime#
# get true extinction rate for 1 regime trees#
tmp <- split(treeDat, treeDat$treeName)#
tmp <- tmp[which(sapply(tmp, nrow) == 1)]#
tmp <- do.call(rbind, tmp)#
muVec <- setNames(tmp$mu0, tmp$treeName)#
muVec <- muVec[datSplit[[1]]$treeName]
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]
datSplit <- split(dat2, dat2$nRegimes)
names(datSplit)
nrow(dat2)
head(dat2)
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 8))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless', 'CRBD_lambda', 'CRBD_mu')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# reorder#
dat <- dat[match(names(trueRatesList), dat$treeName),]
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]
head(dat2)
datSplit <- split(dat2, dat2$nRegimes)
names(datSplit)
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
# just 1 regime#
# get true extinction rate for 1 regime trees#
tmp <- split(treeDat, treeDat$treeName)#
tmp <- tmp[which(sapply(tmp, nrow) == 1)]#
tmp <- do.call(rbind, tmp)#
muVec <- setNames(tmp$mu0, tmp$treeName)#
muVec <- muVec[datSplit[[1]]$treeName]
nrow(datSplit[[1]])
range(muVec)
plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 6))#
	axis(1)#
	axis(2)
head(datSplit[[1]])
for (i in 1:nrow(dat)) {#
	dat[i, 'tipLambda_lambdaTB_PE'] <- propError(estimatedRatesList[[i]]$lambdaTB, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaND_PE'] <- propError(estimatedRatesList[[i]]$lambdaND, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaDR_PE'] <- propError(estimatedRatesList[[i]]$lambdaDR, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaBAMM_PE'] <- propError(estimatedRatesList[[i]]$lambdaBAMM, trueRatesList[[i]]$tipLambda)#
}
# as a function of increasing extinction rate#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
# just 1 regime#
# get true extinction rate for 1 regime trees#
tmp <- split(treeDat, treeDat$treeName)#
tmp <- tmp[which(sapply(tmp, nrow) == 1)]#
tmp <- do.call(rbind, tmp)#
muVec <- setNames(tmp$mu0, tmp$treeName)#
muVec <- muVec[datSplit[[1]]$treeName]#
#
par(mfrow=c(1,4))
i
i<-1
plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(muVec, datSplit[[1]]$)
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]
tipMetric <- paste0('tipLambda_', tipMetric, '_PE')
tipMetric
points(muVec, datSplit[[1]][, tipMetric])
range(datSplit[[1]][, tipMetric])
plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 10))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric])
plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 10))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric], cex=0.3)
mtext('mu', side = 1, cex=0.5, line = 2)
mtext('prop. error', side = 2, cex=0.5, line = 2)
title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 10))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric], cex=0.3)#
	mtext('mu', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
}
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 8))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric], cex=0.3)#
	mtext('mu', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
}
mtext('single regime, constant rate', outer=TRUE, line = -2)
par(mfrow=c(1,2))#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(0, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'highTurnoverBD'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0.25, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0.75, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0.25, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0.75, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0.25, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0.75, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0.25, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0.75, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'high turnover')#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(0, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'LambdaEqualsMu'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0.25, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0.75, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0.25, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0.75, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0.25, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0.75, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0.25, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0.75, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'lambda = mu')
par(mfrow=c(1,2))#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(0, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'highTurnoverBD'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'high turnover')
plot.new()#
plot.window(xlim = c(1,4), ylim = c(0, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'LambdaEqualsMu'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'lambda = mu')
par(mfrow=c(1,2))#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-2, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'highTurnoverBD'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'high turnover')#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-2, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'LambdaEqualsMu'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'lambda = mu')
par(mfrow=c(1,2))#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-1, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'highTurnoverBD'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'high turnover')#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-1, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'LambdaEqualsMu'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
title(main = 'lambda = mu')
mtext('tip rate metric', side = 1, cex=0.5, line = 2)
mtext('prop. error', side = 2, cex=0.5, line = 2)
mtext('tip rate metric', side = 1, cex=1, line = 2)#
mtext('prop. error', side = 2, cex=1, line = 2)
par(mfrow=c(1,2))#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-1, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'highTurnoverBD'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
mtext('tip rate metric', side = 1, cex=1, line = 2)#
mtext('prop. error', side = 2, cex=1, line = 2)#
#
title(main = 'high turnover')#
#
plot.new()#
plot.window(xlim = c(1,4), ylim = c(-1, 4))#
axis(1, at = 1:4, labels = c('TB','ND','DR','BAMM'))#
axis(2)#
qq <- dat[which(dat$setname == 'LambdaEqualsMu'),]#
#
segments(x0 = 1, y0 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 0, na.rm=TRUE), x1 = 1, y1 = quantile(qq[, 'tipLambda_lambdaTB_PE'], 1, na.rm=TRUE))#
points(1, median(qq[,'tipLambda_lambdaTB_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 2, y0 = quantile(qq[, 'tipLambda_lambdaND_PE'], 0, na.rm=TRUE), x1 = 2, y1 = quantile(qq[, 'tipLambda_lambdaND_PE'], 1, na.rm=TRUE))#
points(2, median(qq[,'tipLambda_lambdaND_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 3, y0 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 0, na.rm=TRUE), x1 = 3, y1 = quantile(qq[, 'tipLambda_lambdaDR_PE'], 1, na.rm=TRUE))#
points(3, median(qq[,'tipLambda_lambdaDR_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
segments(x0 = 4, y0 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 0, na.rm=TRUE), x1 = 4, y1 = quantile(qq[, 'tipLambda_lambdaBAMM_PE'], 1, na.rm=TRUE))#
points(4, median(qq[,'tipLambda_lambdaBAMM_PE'], na.rm=TRUE), ylim = c(-1,1), pch=20, cex=0.8)#
#
mtext('tip rate metric', side = 1, cex=1, line = 2)#
mtext('prop. error', side = 2, cex=1, line = 2)#
#
title(main = 'lambda = mu')
# do analyses separately for single/multiregime birth-death models, diversity-dependent, evolvingRates#
# for each tip metric, calculate prop error across numbers of shifts#
# for each tip metric, calculate prop error as a function of extinction rate (leave out DD and evolvingRates)#
# for each tip metric, look at relationship with tree size, what to do about shift number?#
# across tip metrics, what is difference in prop error between tip metric and CRBD?#
#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# proportional error, where x and y are vectors of estimated and true rates, respectively#
# = weighted average of proportional rate differences across all N tips#
propError <- function(x, y) exp((1/length(x)) * sum(log(x) - log(y)))#
#
# calculate proportional error between true and estimated rates for each tree#
# table will include treename, number of shifts, whether it's birth-death, diversity-dependent or evolvingRates, number of tips, colless, crbd lambda and mu, and tip correlations.#
#
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 8))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless', 'CRBD_lambda', 'CRBD_mu')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# reorder#
dat <- dat[match(names(trueRatesList), dat$treeName),]#
#
# calculate proportional error of estimated to true true lambda tip rates for each different tip rate metric#
#
for (i in 1:nrow(dat)) {#
	dat[i, 'tipLambda_lambdaTB_PE'] <- propError(estimatedRatesList[[i]]$lambdaTB, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaND_PE'] <- propError(estimatedRatesList[[i]]$lambdaND, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaDR_PE'] <- propError(estimatedRatesList[[i]]$lambdaDR, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaBAMM_PE'] <- propError(estimatedRatesList[[i]]$lambdaBAMM, trueRatesList[[i]]$tipLambda)#
}
# do analyses separately for single/multiregime birth-death models, diversity-dependent, evolvingRates#
# for each tip metric, calculate prop error across numbers of shifts#
# for each tip metric, calculate prop error as a function of extinction rate (leave out DD and evolvingRates)#
# for each tip metric, look at relationship with tree size, what to do about shift number?#
# across tip metrics, what is difference in prop error between tip metric and CRBD?#
#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# proportional error, where x and y are vectors of estimated and true rates, respectively#
# = weighted average of proportional rate differences across all N tips#
propError <- function(x, y) exp((1/length(x)) * sum(log(x) - log(y)))#
#
# calculate proportional error between true and estimated rates for each tree#
# table will include treename, number of shifts, whether it's birth-death, diversity-dependent or evolvingRates, number of tips, colless, crbd lambda and mu, and tip correlations.#
#
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 8))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless', 'CRBD_lambda', 'CRBD_mu')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# reorder#
dat <- dat[match(names(trueRatesList), dat$treeName),]#
#
# calculate proportional error of estimated to true true lambda tip rates for each different tip rate metric#
#
for (i in 1:nrow(dat)) {#
	dat[i, 'tipLambda_lambdaTB_PE'] <- propError(estimatedRatesList[[i]]$lambdaTB, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaND_PE'] <- propError(estimatedRatesList[[i]]$lambdaND, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaDR_PE'] <- propError(estimatedRatesList[[i]]$lambdaDR, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaBAMM_PE'] <- propError(estimatedRatesList[[i]]$lambdaBAMM, trueRatesList[[i]]$tipLambda)#
}#
#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error summarized across number of regimes#
### multi-regime birth-death#
#
# plot the 25-75% quantile range, and median of proportional error between true lambda tip and different tip rate metrics, in relation to the number of regimes#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(0, 6))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.75, na.rm=TRUE)))#
	points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
mtext('multi-regime constant-rate', outer=TRUE, line = -2)
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(0, 6))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.75, na.rm=TRUE)))#
	points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
mtext('multi-regime diversity-dependent', outer=TRUE, line = -2)
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error as a function of mu#
### single-regime birth-death#
#
# as a function of increasing extinction rate#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
# just 1 regime#
# get true extinction rate for 1 regime trees#
tmp <- split(treeDat, treeDat$treeName)#
tmp <- tmp[which(sapply(tmp, nrow) == 1)]#
tmp <- do.call(rbind, tmp)#
muVec <- setNames(tmp$mu0, tmp$treeName)#
muVec <- muVec[datSplit[[1]]$treeName]#
#
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 8))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric], cex=0.3)#
	mtext('mu', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
}#
mtext('single regime, constant rate', outer=TRUE, line = -2)
head(dat)
i<-1
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat$nTips)), ylim = c(0, 6))
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat$nTips), ylim = c(0, 6))
axis(1)
axis(2)
points(dat$nTips, tipMetric)
points(dat$nTips, dat[,tipMetric])
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat$nTips, dat[,tipMetric], cex=0.25)
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat$nTips, dat[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
unique(dat$setname)
# leaving out diversity-dependent and evolvingRatesd
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]
# for now, using all simulation scenarios, all nRegimes#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
# leaving out diversity-dependent and evolvingRates#
#
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]
nrow(dat2)
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
par(mfrow=c(3,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
mtext('multi-regime diversity-dependent', outer=TRUE, side = 1, line = -2)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = -2)
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
par(mfrow=c(3,4), mar = c(3,3,1,1))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
?par
par('oma')
par(mfrow=c(3,4), mar = c(3,3,1,1), oma = c(0,2,0,0))#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = -2)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = -1)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.2)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.1)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.9)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.95)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.5)
par(mfrow=c(3,4), mar = c(3,3,1,1), oma = c(0,2,0,0))#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
mtext('multi-regime constant-rate', outer=TRUE, side = 2, line = 0.2, adj=0.1)#
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.95)#
mtext('single-regime evolving lambda', outer=TRUE, side = 2, line = 0.2, adj=0.5)
mtext('single-regime evolving lambda', outer=TRUE, side = 2, line = 0.2, adj=0.5, cex=0.75)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.95, cex=0.75)
mtext('multi-regime constant-rate', outer=TRUE, side = 2, line = 0.2, adj=0.1, cex=0.75)
par(mfrow=c(3,4), mar = c(3,3,1,1), oma = c(0,2,0,0))#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
mtext('multi-regime constant-rate', outer=TRUE, side = 2, line = 0.2, adj=0.1, cex=0.75)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.95, cex=0.75)
mtext('single-regime evolving lambda', outer=TRUE, side = 2, line = 0.2, adj=0.5, cex=0.75)
par(mfrow=c(3,4), mar = c(3,3,1,1), oma = c(0,2,0,0))#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
mtext('multi-regime constant-rate', outer=TRUE, side = 2, line = 0.2, adj=0.95, cex=0.5)#
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.1, cex=0.5)#
mtext('single-regime evolving lambda', outer=TRUE, side = 2, line = 0.2, adj=0.5, cex=0.5)
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.55, cex=0.5)
par(mfrow=c(3,4), mar = c(3,3,1,1), oma = c(0,2,0,0))#
#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2',  'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
dat2 <- dat[which(dat$setname %in% 'evolvingRates'),]#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = range(dat2$nTips), ylim = c(0, 6))#
	axis(1)#
	axis(2)#
	points(dat2$nTips, dat2[,tipMetric], cex=0.25)#
	mtext('tree size', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
#	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}#
#
mtext('multi-regime constant-rate', outer=TRUE, side = 2, line = 0.2, adj=0.95, cex=0.5)#
mtext('multi-regime diversity-dependent', outer=TRUE, side = 2, line = 0.2, adj=0.55, cex=0.5)#
mtext('single-regime evolving lambda', outer=TRUE, side = 2, line = 0.2, adj=0.1, cex=0.5)
i<-1
head(dat)
propError(estimatedRatesList[[i]]$lambdaTB, trueRatesList[[i]]$tipLambda)
propError(rep(dat[i, 'CRBD_lambda'], length(trueRatesList[[i]]$tipLambda)), trueRatesList[[i]]$tipLambda)
for (i in 1:nrow(dat)) {#
	dat[i, 'tipLambda_lambdaTB_PE'] <- propError(estimatedRatesList[[i]]$lambdaTB, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaND_PE'] <- propError(estimatedRatesList[[i]]$lambdaND, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaDR_PE'] <- propError(estimatedRatesList[[i]]$lambdaDR, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_lambdaBAMM_PE'] <- propError(estimatedRatesList[[i]]$lambdaBAMM, trueRatesList[[i]]$tipLambda)#
	dat[i, 'tipLambda_CRBDlambda_PE'] <- propError(rep(dat[i, 'CRBD_lambda'], length(trueRatesList[[i]]$tipLambda)), trueRatesList[[i]]$tipLambda)#
}
head(dat)
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])
i<-1
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(0, 6))
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))
axis(2)
head(datSpli[[1]])
head(datSplit[[1]])
points(x = as.numeric(names(datSplit)), y = sapply(datSplit[[i]], function(x) median(x[, tipMetric])))
sapply(datSplit[[i]], function(x) median(x[, tipMetric])
)
sapply(datSplit, function(x) median(x[, tipMetric]))
points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, tipMetric])))
points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, 'tipLambda_CRBDlambda_PE'])))
points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, tipMetric])))#
	points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, 'tipLambda_CRBDlambda_PE'])), pch=20)
sapply(datSplit, function(x) median(x[, tipMetric]) - median(x[, 'tipLambda_CRBDlambda_PE']))
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(0, 6))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, tipMetric]) - median(x[, 'tipLambda_CRBDlambda_PE'])))#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('diff in prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
i<-2
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(0, 6))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
sapply(datSplit, function(x) median(x[, tipMetric]))
sapply(datSplit, function(x) median(x[, 'tipLambda_CRBDlambda_PE']))
sapply(datSplit, function(x) median(x[, tipMetric]) - median(x[, 'tipLambda_CRBDlambda_PE']))
par(mfrow=c(1,4))
tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(-3, 4))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)
points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, tipMetric]) - median(x[, 'tipLambda_CRBDlambda_PE'])))
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')#
	plot.new()#
	plot.window(xlim = c(range(as.numeric(names(datSplit)))), ylim = c(-3, 4))#
	axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
	axis(2)#
	points(x = as.numeric(names(datSplit)), y = sapply(datSplit, function(x) median(x[, tipMetric]) - median(x[, 'tipLambda_CRBDlambda_PE'])))#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('diff in prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
#
}
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])
head(at)
head(dat)
tipMetric <- paste0('tipLambda_CRBD_lambda_PE')
plot.new()
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 6))
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))
tipMetric <- paste0('tipLambda_CRBD_lambda_PE')#
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 6))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.75, na.rm=TRUE)))
tipMetric
as.numeric(names(datSplit))
sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE))
tipMetric <- paste0('tipLambda_CRBDlambda_PE')
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.75, na.rm=TRUE)))
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)
mtext('nRegimes', side = 1, cex=0.5, line = 2)
mtext('prop. error', side = 2, cex=0.5, line = 2)
title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)
abline(h=1, lty=3)
tipMetric <- paste0('tipLambda_CRBDlambda_PE')#
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 2))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)#
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.25, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.75, na.rm=TRUE)))#
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)#
mtext('nRegimes', side = 1, cex=0.5, line = 2)#
mtext('prop. error', side = 2, cex=0.5, line = 2)
title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)
abline(h=1, lty=3)
tipMetric <- paste0('tipLambda_CRBDlambda_PE')#
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 2))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 1, na.rm=TRUE)))
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 5))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)#
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 1, na.rm=TRUE)))#
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 10))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)#
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 1, na.rm=TRUE)))#
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 4))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)#
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.05, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.95, na.rm=TRUE)))#
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)
abline(h=1, lty=3)
head(dat)
treeDat[1,]
treeDat[which(treeDat$treeName == 'evolvingRates_1'),]
which(names(trueRatesList) == 'evolvingRates_1')
head(trueRatesList[[1]])
tipMetric <- paste0('tipLambda_CRBDlambda_PE')#
plot.new()#
plot.window(xlim = range(as.numeric(names(datSplit))), ylim = c(0, 4))#
axis(1, at = as.numeric(names(datSplit)), labels = names(datSplit))#
axis(2)#
segments(x0 = as.numeric(names(datSplit)), y0 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.05, na.rm=TRUE)), x1 = as.numeric(names(datSplit)), y1 = sapply(datSplit, function(x) quantile(x[, tipMetric], 0.95, na.rm=TRUE)))#
points(as.numeric(names(datSplit)), sapply(datSplit, function(x) median(x[, tipMetric], na.rm=TRUE)), ylim = c(-1,1), pch=20, cex=0.8)#
mtext('nRegimes', side = 1, cex=0.5, line = 2)#
mtext('prop. error', side = 2, cex=0.5, line = 2)#
title(main = 'CRBD lambda', line = -0.5)#
abline(h=1, lty=3)
mtext('multi-regime constant-rate', outer=TRUE, line = -2)
# as a function of increasing extinction rate#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
#
# just 1 regime#
# get true extinction rate for 1 regime trees#
tmp <- split(treeDat, treeDat$treeName)#
tmp <- tmp[which(sapply(tmp, nrow) == 1)]#
tmp <- do.call(rbind, tmp)#
muVec <- setNames(tmp$mu0, tmp$treeName)#
muVec <- muVec[datSplit[[1]]$treeName]#
#
par(mfrow=c(1,4))#
#
for (i in 1:4) {#
	plot.new()#
	plot.window(xlim = range(muVec), ylim = c(0, 8))#
	axis(1)#
	axis(2)#
	tipMetric <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i]#
	tipMetric <- paste0('tipLambda_', tipMetric, '_PE')	#
	points(muVec, datSplit[[1]][, tipMetric], cex=0.3)#
	mtext('mu', side = 1, cex=0.5, line = 2)#
	mtext('prop. error', side = 2, cex=0.5, line = 2)#
	title(main = c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')[i], line = -0.5)#
	abline(h=1, lty=3)#
}#
mtext('single regime, constant rate', outer=TRUE, line = -2)
# create execution .sh files#
workingDir <- '~/Desktop/pascal/'#
setname <- 'evolvingRates'#
#
all <- 1:1200#
#
done <- c(1:33, 151:169, 301:341, 451:472, 601:647, 751:778, 901:950, 1051:1090)#
#
left <- setdiff(all, done)#
#
N <- 17 # number of separate .sh files to create#
#
batches <- split(left, sample(1:N, length(left), replace=T))
batches
# also track:#
#- tree name#
#- tip name#
#- regime tip belongs to#
#
basepath <- '~/Dropbox/tipRatesProject/trees/'#
#
outfile <- '~/Dropbox/tipRatesProject/trueTipRates.csv'#
#
# tree summary file#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
require(ape)#
require(geiger)#
#
source('~/Dropbox/tipRatesProject/sourceFxns.R')#
#
evolvingRates_trees_alltips <- readRDS('~/Dropbox/tipRatesProject/simulations/evolvingRates/evolvingRates_trees_alltips.rds')#
trueTipDat <- vector('list', length = length(unique(treeDat$treeName)))#
names(trueTipDat) <- unique(treeDat$treeName)#
# for pure birth and birth death, these are constant rate, therefore tip rates will be same as initial regime rates.#
#
# diversity-dependent model:#
# lambda_n = lambda0 * (1 - nTips / K)#
tipLambdaDD <- function(lambda0, nTips, K) lambda0 * (1 - nTips / K)#
#
# evolving rates model#
# trees have been saved that include rates for all branches#
# If more than one event in tree, then calculate tip rates from oldest regime to most recent, such that more recent regimes replace tip rates appropriately. #
# (nested regimes will replace root regime tip calculations)#
#
tipTableColumns <- c('treeName','setname','tipName','regimeID','tipLambda','tipMu','regimePathLambda','regimePathMu','root2tipLambda','root2tipMu')
treeInd <- unique(treeDat[which(treeDat$setname %in% c('MitchellRabosky2016', 'MeyerWiens2017', 'MooreEtAl2016', 'RaboskyEtAl2017', 'highTurnoverBD', 'LambdaEqualsMu', 'fossilBAMM')), 'treeName'])
i<-1
treeInd[i]
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]
modelDat
tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))#
	tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	# order ascending by regimeTime (regimeTime is time from root)#
	modelDat <- modelDat[order(modelDat$regimeTime, decreasing = FALSE),]#
	for (j in 1:nrow(modelDat)) {#
		regimeTips <- tips(tr, modelDat[j, 'regimeMRCA'])#
		tipInd <- which(tipTable$tipName %in% regimeTips)#
		tipTable[tipInd, 'regimeID'] <- paste0('regime', j)#
		tipTable[tipInd, c('tipLambda', 'tipMu')] <- modelDat[j, c('lambda0', 'mu0')]#
	}#
	# path metrics#
	pathMetrics <- calcMeanPath(tr, modelDat)#
	tipTable[, 'regimePathLambda'] <- pathMetrics$regime2tipLambda#
	tipTable[, 'regimePathMu'] <- pathMetrics$regime2tipMu#
	tipTable[, 'root2tipLambda'] <- pathMetrics$root2tipLambda#
	tipTable[, 'root2tipMu'] <- pathMetrics$root2tipMu
tr
head(tipTable)
trueTipDat[[treeInd[i]]] <- tipTable
head(trueTipDat[treeInd[i]])
# --------------------------------------#
## diversity-dependent models#
treeInd <- unique(treeDat[which(treeDat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')), 'treeName'])#
#
# for these models, we will use the lambda and mu trees supplied in Rabosky 2014.#
# in these trees, branches have been scaled by their mean lambda and mu#
#
# tip rates will be terminal edge lambda and mu#
# for mean path rates, #
# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
#
Rabosky2014path <- '~/Dropbox/tipRatesProject/simulationRefs/Rabosky2014/'
i<-1
treeInd[i]
i<-20
treeInd[i]
i<-600
treeInd[i]
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	nShifts <- gsub('Rabosky2014_DD_k(\\d)_\\d+', '\\1', treeInd[i])#
	treeNum <- as.numeric(gsub('Rabosky2014_DD_k\\d_(\\d+)$', '\\1', treeInd[i]))#
	lambdaTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt'))[[treeNum]]#
	muTree <- read.tree(paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt'))[[treeNum]]#
	tr <- read.tree(paste0(basepath, treeInd[i], '/', treeInd[i], '.tre'))
modelDat
nShifts
treeNum
paste0(Rabosky2014path, 'dd_k', nShifts, '/lambdaTrees.txt')
paste0(Rabosky2014path, 'dd_k', nShifts, '/muTrees.txt')
paste0(basepath, treeInd[i], '/', treeInd[i], '.tre')
tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns
tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1,'setname']#
	tipTable[, 'tipName'] <- tr$tip.label#
	# tip rates#
	terminalEdges <- getTerminalEdgeIndex(lambdaTree)#
	tipTable[, 'tipLambda'] <- lambdaTree$edge.length[terminalEdges]#
	tipTable[, 'tipMu'] <- muTree$edge.length[terminalEdges]#
	# # calculate speciation rate at the tips#
	# for (j in 1:nrow(modelDat)) {#
		# regimeTips <- tips(tr, modelDat[j, 'regimeMRCA'])#
		# if (modelDat[j, 'processType'] == 'diversity-dependent') {#
			# tipTable[which(tipTable$tipName %in% regimeTips), 'tipLambda'] <- tipLambdaDD(modelDat[j, 'lambda0'], modelDat[j, 'regime_nTips'], modelDat[j, 'K'])#
			# tipTable[which(tipTable$tipName %in% regimeTips), 'tipMu'] <- modelDat[j, 'mu0']#
		# } else {#
			# tipTable[which(tipTable$tipName %in% regimeTips), 'tipLambda'] <- modelDat[j, 'lambda0']#
			# tipTable[which(tipTable$tipName %in% regimeTips), 'tipMu'] <- modelDat[j, 'mu0']#
		# }#
	# }#
	# # tipLambda cannot be < 0, so set those to 0#
	# if (any(tipTable$tipLambda < 0)) {#
		# tipTable[which(tipTable$tipLambda < 0), 'tipLambda'] <- 0#
	# }#
	# calculate root-to-tip mean rates#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:length(tr$tip.label)) {#
		edgeIndices <- root2tipEdges(tr, sp = tr$tip.label[j])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(lambdaTree$edge.length[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(muTree$edge.length[edgeIndices], w = edgeWeights)#
	}#
	# calculate regime-to-tip mean rates#
	for (j in 1:nrow(modelDat)) {#
		if (modelDat[j, 'regime_nTips'] > 1) {#
#
			subClade <- extract.clade(tr, modelDat[j, 'regimeMRCA'])#
			subLambda <- extract.clade(lambdaTree, modelDat[j, 'regimeMRCA'])#
			subMu <- extract.clade(muTree, modelDat[j, 'regimeMRCA'])#
			maxBT <- max(NU.branching.times(subClade))#
			tipTable[which(tipTable$tipName %in% subClade$tip.label), 'regimeID'] <- paste0('regime', j)#
			for (k in 1:length(subClade$tip.label)) {#
				edgeIndices <- root2tipEdges(subClade, sp = subClade$tip.label[k])#
				edgeWeights <- subClade$edge.length[edgeIndices] / maxBT#
				tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- weighted.mean(subLambda$edge.length[edgeIndices], w = edgeWeights)#
				tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- weighted.mean(subMu$edge.length[edgeIndices], w = edgeWeights)#
			}#
		} else {#
			# shift on a terminal branch#
			# path lambda and mu are just the terminal branch rate#
			# which terminal branch?#
			edgeInd <- which(tr$edge[,2] == modelDat[j, 'regimeMRCA'])#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathLambda'] <- lambdaTree$edge.length[edgeInd]#
			tipTable[which(tipTable$tipName == subClade$tip.label[k]), 'regimePathMu'] <- muTree$edge.length[edgeInd]#
		}#
	}
head(tipTable)
tail(tipTable)
trueTipDat[[treeInd[i]]] <- tipTable
trueTipDat[treeInd[i]]
# --------------------------------------#
## evolving rates model#
treeInd <- unique(treeDat[which(treeDat$setname == 'evolvingRates'), 'treeName'])#
#
# for these models, we will use branch-specific lambda and mu.#
#
# tip rates will be terminal edge lambda and mu#
# path rates will be the weighted mean path rates, where weights are branch lengths from time tree
i<-700
cat(i, 'of', length(treeInd), '\n')#
	modelDat <- treeDat[which(treeDat$treeName == treeInd[i]),]#
	# fetch tree#
	tr <- evolvingRates_trees_alltips[[as.numeric(gsub('evolvingRates_', '', modelDat$treeName))]]#
	trPruned <- drop.extinct(tr)#
	tipTable <- as.data.frame(matrix(nrow = length(trPruned$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable[, 'treeName'] <- treeInd[i]#
	tipTable[, 'setname'] <- modelDat[1, 'setname']#
	tipTable[, 'tipName'] <- trPruned$tip.label#
	tipTable[, 'regimeID'] <- 'regime1'#
	# add branch-specific mu to object#
	# as epsilon was kept constant in this model, we can calculate mu based on the terminal branch lambda and the tree-wide eps. mu = eps * lambda#
	eps <- modelDat$mu0 / modelDat$lambda0#
	tr$mu <- tr$lambda * eps#
	# tip rates#
	tipTable$tipLambda <- getTerminalLambda(tr)#
	tipTable$tipMu <- getTerminalMu(tr)#
#
	# for mean lambda and mu along path from root to tip,#
	# we will take a weighted arithmetic mean of the branch rates, weighted by their branch lengths, as percentages of the tree depth#
	maxBT <- max(NU.branching.times(tr))#
	for (j in 1:nrow(tipTable)) {#
		edgeIndices <- root2tipEdges(tr, sp = tipTable[j, 'tipName'])#
		edgeWeights <- tr$edge.length[edgeIndices] / maxBT#
		tipTable[j, 'root2tipLambda'] <- weighted.mean(tr$lambda[edgeIndices], w = edgeWeights)#
		tipTable[j, 'root2tipMu'] <- weighted.mean(tr$mu[edgeIndices], w = edgeWeights)#
	}#
	# regime path is same as root2tip as there is a single regime#
	tipTable[, 'regimePathLambda'] <- tipTable[, 'root2tipLambda']#
	tipTable[, 'regimePathMu'] <- tipTable[, 'root2tipMu']
modelDat
treeInd[i]
as.numeric(gsub('evolvingRates_', '', modelDat$treeName))
head(tipTable)
trueTipDat[[treeInd[i]]] <- tipTable
trueTipDat[treeInd[i]]
# Infer tip rates#
#- with BAMM#
#- DR stat#
#- node density#
#- inverse terminal branch length#
#- constant-rate-birth-death#
#
basepath <- '~/Dropbox/tipRatesProject/trees/'#
treefolders <- list.files(basepath)#
#
outfile <- '~/Dropbox/tipRatesProject/estimatedTipRates.csv'#
#
require(ape)#
require(geiger)#
require(BAMMtools)#
require(phangorn)#
require(phytools)
source('~/Dropbox/tipRatesProject/tipRateFunctions.R')#
source('~/Dropbox/tipRatesProject/sourceFxns.R')
tipTableColumns <- c('treeName','setname','tipName','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')
# reorder treefolders#
treefolders <- treefolders[order(gsub('(.+)_(\\d+)$', '\\1', treefolders), as.numeric(gsub('(.+)_(\\d+)$', '\\2', treefolders)))]#
#
estimRatesList <- vector('list', length(treefolders))#
names(estimRatesList) <- treefolders#
#
BAMMmissing <- c()
head(treefolders)
i<-3000
treefolders[i]
cat(i, 'of', length(treefolders), '\n')#
	setwd(paste0(basepath, treefolders[i]))#
	files <- list.files()
files
tr <- read.tree(grep('\\.tre$', files, value = TRUE))
tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable$treeName <- treefolders[i]#
	tipTable$setname <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	tipTable$tipName <- tr$tip.label
head(tipTable)
# inverse terminal branch lengths#
	tipTable$lambdaTB <- inverseTerminalBranches(tr)#
	# node density#
	tipTable$lambdaND <- nodeDensity(tr)#
	# DR#
	tipTable$lambdaDR <- DRstat(tr)
any(grepl('event_data.txt|event_out.txt', files))
'tiprates.csv' %in% files
tipTable$lambdaBAMM <- read.csv('tiprates.csv')$bammTipLambda
treefolders[i]
tipTable <- as.data.frame(matrix(nrow = length(tr$tip.label), ncol = length(tipTableColumns)))#
	colnames(tipTable) <- tipTableColumns#
	tipTable$treeName <- treefolders[i]#
	tipTable$setname <- gsub('(.+)_(\\d+)$', '\\1', treefolders[i])#
	tipTable$tipName <- tr$tip.label#
	# inverse terminal branch lengths#
	tipTable$lambdaTB <- inverseTerminalBranches(tr)#
	# node density#
	tipTable$lambdaND <- nodeDensity(tr)#
	# DR#
	tipTable$lambdaDR <- DRstat(tr)#
	# BAMM results can either be in the form of BAMM data files, or as a file containing tip rates#
	if (any(grepl('event_data.txt|event_out.txt', files))) {#
		ed <- getEventData(tr, grep('event_data.txt|event_out.txt', files, value = TRUE), burnin=0.5, nsamples=1000)#
		tipTable$lambdaBAMM <- ed$meanTipLambda#
	} else if ('tiprates.csv' %in% files) {#
		tipTable$lambdaBAMM <- read.csv('tiprates.csv')$bammTipLambda#
	} else {#
		# BAMM files not present. log this.#
		BAMMmissing <- c(BAMMmissing, treefolders[i])#
	}
estimRatesList[[treefolders[i]]] <- tipTable
estimatedRatesList[treefolders[i]]
estimRatesList[treefolders[i]]
