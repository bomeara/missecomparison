i<-1
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))
if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = range(as.numeric(names(datSplit))), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))
axis(2, at = c(-0.25, axTicks(2)))
j<-1
qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)
rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)
qStats
for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}
as.numeric(names(datSplit))
j
datSplit[[j]]
qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)
qStats
for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}
plot.new()
plot.window(xlim = c(1, 5.5), ylim = yrange)
axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))
axis(2, at = c(-0.25, axTicks(2)))
plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))
axis(2, at = c(-0.25, axTicks(2)))
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)
i<-1
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))
axis(2, at = c(-0.25, axTicks(2)))
for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)
i
i<-1
j<-1
tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}
plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))
names(datSplit))
names(datSplit)
plot.new()
plot.window(xlim = c(0.5,3.5), ylim = yrange)
axis(1, at = 1:3, labels = names(datSplit))
axis(2)
axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))
plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2))
axTicks(2)
plot.new()
plot.window(xlim = c(0.5,3.5), ylim = yrange)
axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))
axis(2, at = c(-0.25, axTicks(2)))
for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}
qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)
qStats
for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)
# combined figure of all 5 tip rate metrics, under 3 scenarios#
#
rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')#
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(qrange))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5)#
	}#
}
qrange
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/2, qStats[1], j + width/2, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5)#
	}#
}
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5)#
	}#
}
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=10, height=7)#
par(mfrow = c(3, 5))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5)#
	}#
}#
dev.off()
?par
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=10, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,2,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
# plot tip rate values against each other, no by-tree or by-regime summarizing#
#
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
table(dat$setname)#
#
# # MitchellRabosky2016: single-regime birth-death#
# # RaboskyEtAl2017: multi-regime birth-death#
# # fossilBAMMDD: single-regime diversity-dependent#
# # evolvingRates#
# setsToUse <- c('MitchellRabosky2016','RaboskyEtAl2017','fossilBAMMDD','evolvingRates')#
#
# plotLabels <- c('single-regime, constant-rate', 'multi-regime, constant-rate', 'single-regime, diversity-dependent', 'continuous rate variation')#
#
# gridVal <- 500#
# png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates.png', width=5, height=12, units='in', res=300)#
# par(mfrow=c(4,2))#
#
# for (i in 1:length(setsToUse)) {#
	# qq <- dat[which(dat$setname == setsToUse[i]),]#
#
	# plot.new()#
	# plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	# axis(1)#
	# axis(2)#
	# mtext('true lambda', side=1, line = 2.5)#
	# mtext('lambdaDR', side=2, line = 2.5)#
	# heatscatterpoints(qq$tipLambda, qq$lambdaDR, grid= gridVal)#
	# abline(a=0, b=1, lty=3)#
	# plot.new()#
	# plot.window(xlim = c(0, 0.5), ylim = c(0, 0.5))#
	# axis(1)#
	# axis(2)#
	# mtext('true lambda', side=1, line = 2.5)#
	# mtext('lambdaBAMM', side=2, line = 2.5)	#
	# heatscatterpoints(qq$tipLambda, qq$lambdaBAMM, grid= gridVal)#
	# abline(a=0, b=1, lty=3)#
	# mtext(plotLabels[i], line = 1, at=-0.15, xpd=NA)#
# }#
#
# dev.off()#
# bigger figure: all tip metrics, for both lambda and net div#
#
setlist <- list('multi-regime, time-constant'= c('fossilBAMM', 'highTurnoverBD', 'LambdaEqualsMu','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'multi-regime, diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')#
#
tipMetrics <- c('lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
titleLine <- c(-2, -28, -52, -79, -104, -128)
i<-2
j<-2
gridVal <- 50
qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0.05, 0.95))
cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))
quantile(qq$tipLambda, c(0.05, 0.95))
quantile(qq[, tipMetrics[j]], c(0.05, 0.95))
heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
yrange
axisRange
axisRange <- c(0, 0.2)
plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)
nrow(qq[, tipMetrics[j]])
tipMetrics[j]
head(qq[, tipMetrics[j]])
length(qq[, tipMetrics[j]])
plot(qq$tipLambda, qq[, tipMetrics[j]], cex=0.3)
heatscatter(qq$tipLambda, qq[, tipMetrics[j]])
abline(a=0, b=1, lty=3)
?heatscatter)
?heatscatter
heatscatter
?heatscatterpoints
heatscatterpoints
heatscatter(qq$tipLambda, qq[, tipMetrics[j]], grid=1000)
gridVal <- 500
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBigNetDiv.png', width=10, height=10, units='in', res=300)
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0.05, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
warnings()
# read in true and estimated rates, and calculate error metrics#
#
## Read in datasets#
trueRates <- read.csv('~/Dropbox/tipRatesProject/trueTipRates.csv', stringsAsFactors=FALSE)#
estimatedRates <- read.csv('~/Dropbox/tipRatesProject/estimatedTipRates.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
crbd <- read.csv('~/Dropbox/tipRatesProject/estimatedCRBD.csv', stringsAsFactors=FALSE)#
#
outfile <- '~/Dropbox/tipRatesProject/rateErrorMetrics.csv'#
# ----------------------------------------------------#
# Combine true and estimated datasets into one object#
#
trueRatesList <- split(trueRates, trueRates$treeName)#
estimatedRatesList <- split(estimatedRates, estimatedRates$treeName)#
#
# make sure lists are in the same order, and tips are in the same order in each list element#
identical(names(trueRatesList), names(estimatedRatesList))#
#
for (i in 1:length(trueRatesList)) {#
	xx <- trueRatesList[[i]]$tipName#
	xx <- sort(xx)#
	trueRatesList[[i]] <- trueRatesList[[i]][match(xx, trueRatesList[[i]]$tipName),]#
	estimatedRatesList[[i]] <- estimatedRatesList[[i]][match(xx, estimatedRatesList[[i]]$tipName),]#
}#
#
# put CRBD table in same order#
ordering <- sapply(names(trueRatesList), function(x) which(crbd$treeName == x))#
crbd <- crbd[ordering,]#
#
# merge the two, and add CRBD lambda and mu (identical values across tip names)#
allRatesList <- vector('list', length = length(trueRatesList))#
names(allRatesList) <- names(trueRatesList)#
for (i in 1:length(trueRatesList)) {#
	allRatesList[[i]] <- cbind.data.frame(trueRatesList[[i]], estimatedRatesList[[i]][, c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM', 'netDivBAMM')], CRBDlambda = crbd[i, 'lambda'], CRBDmu = crbd[i, 'mu'])#
}#
#
saveRDS(allRatesList, '~/Dropbox/tipRatesProject/allRatesList.rds')#
#
### -----------------------------#
#
meanAbsoluteError <- function(estimated, true) {#
	mean(estimated - true)#
}#
#
absoluteError <- function(estimated, true) {#
	mean(abs(estimated - true))#
}#
#
# PROPORTIONAL ERROR METRICS (from Rabosky et al. 2014 appendix)#
#
# estimated = vector of estimated tip values#
# true = true tip values#
#
# overall mean proportional error#
propError1 <- function(estimated, true) {#
	sum((estimated - true) / true) / length(true)#
}#
#
# overall mean proportional errror, weighted by the relative size of the regime#
# regimeVec is a categorical vector of regimeID of the same length as vec estimated and vec true.#
# it should represent the relative size of the regime, to the whole tree#
propError2 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	sum(((estimated - true) / true) * regimeVec)#
}#
#
# mean error over all tips, using log-transformed rates#
propError3 <- function(estimated, true) {#
	exp(sum(log(estimated) - log(true)) / length(true))#
}#
#
# mean error over all tips, using log-transformed rates, where rates are weighted by regime size.#
propError4 <- function(estimated, true, regimeVec) {#
	regimeVecProp <- setNames(as.numeric(table(regimeVec) / length(regimeVec)), names(table(regimeVec)))#
	regimeVec <- regimeVecProp[regimeVec]#
	exp(sum((log(estimated) - log(true)) * regimeVec))#
}#
# ols regression R2 and slope#
olsRegression <- function(estimated, true) {#
	if (!all(is.na(estimated))) {#
		ols <- lm(estimated ~ true)#
		if (nrow(summary(ols)$coefficients) > 1) {#
			setNames(c(summary(ols)$coefficients[2,1], summary(ols)$adj.r.squared), c('slope','r2'))#
		} else {#
			setNames(c(NA, NA), c('slope','r2'))#
		}#
	} else {#
		setNames(c(NA, NA), c('slope','r2'))#
	}#
}#
#
# -----------------------------------------------#
#
# calculate different error metrics between true and estimated rates for each tree#
#
dat <- as.data.frame(matrix(nrow = nrow(crbd), ncol = 6))#
colnames(dat) <- c('treeName', 'setname', 'nTips', 'nRegimes', 'processType', 'colless')#
#
dat[, c('treeName','setname', 'CRBD_lambda', 'CRBD_mu', 'colless')] <- crbd[,c('treeName','setname','lambda','mu','colless')]#
#
for (i in 1:nrow(dat)) {#
	tmp <- treeDat[which(treeDat$treeName == dat[i, 'treeName']),]#
	dat[i, 'nTips'] <- tmp[1, 'nTips_all']#
	dat[i, 'nRegimes'] <- nrow(tmp)#
	if (grepl('Rabosky2014', tmp[1, 'setname'])) {#
		dat[i, 'processType'] <- 'diversity-dependent'#
	} else if (tmp[1, 'setname'] == 'evolvingRates') {#
		dat[i, 'processType'] <- 'evolvingRates'#
	} else {#
		dat[i, 'processType'] <- 'birth-death'#
	}#
}#
#
# check ordering#
identical(names(allRatesList), dat$treeName)#
#
# calculate proportional error of estimated to true true lambda tip rates for each different tip rate metric#
#
tipMetricHeaders <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricHeadersNetDiv <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
#
for (i in 1:nrow(dat)) {#
	for (j in 1:length(tipMetricHeaders)) {#
		# speciation rate#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[1]#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)[2]#
#
		#dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
#
		dat[i, paste0('tipLambda_', tipMetricHeaders[j], '_absoluteError')] <- absoluteError(allRatesList[[i]][, tipMetricHeaders[j]], allRatesList[[i]]$tipLambda)#
		# Net diversification rate#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE1')] <- propError1(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE2')] <- propError2(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE3')] <- propError3(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_PE4')] <- propError4(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv, allRatesList[[i]]$regimeID)#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_slope')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[1]#
#
		dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_r2')] <- olsRegression(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)[2]#
#
	#dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_absoluteError')] <- meanAbsoluteError(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
	dat[i, paste0('tipNetDiv_', tipMetricHeadersNetDiv[j], '_absoluteError')] <- absoluteError(allRatesList[[i]][, tipMetricHeadersNetDiv[j]], allRatesList[[i]]$tipNetDiv)#
#
	}#
}#
#
head(dat)#
#
write.csv(dat, outfile, row.names=FALSE)
# Analyze proportional error in rates as a function of number of regimes#
#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
#
# set infinite values to NA#
for (i in 6:ncol(dat)) {#
	if (length(which(!is.finite(dat[,i]))) > 0) {#
		dat[which(!is.finite(dat[,i])), i] <- NA#
	}#
}
rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- c(-0.2, 0.2)#
	} else {#
		yrange <- quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), c(0.025, 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.5)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.4)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.4)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
defaultYrange <- c(0, 0.2)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
defaultYrange <- c(0, 0.4)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2)#
		segments(j, qStats[4], j, qStats[5], lty=2)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1])#
		segments(j - width/3, qStats[5], j + width/3, qStats[5])#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
?segments
pdf('~/Dropbox/tipRatesProject/preliminaryplots/heterogeneity_allboxplots.pdf', width=12, height=7)#
par(mfrow = c(3, 5), mar = c(4,4,3,1))#
#
width <- 0.4#
rateType <- 'Lambda'#
qrange <- c(0.05, 0.95)#
defaultYrange <- c(0, 0.4)#
errorMetric <- 'absoluteError'#
## time-constant multi-regime#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
# collapse shift number >= 10 into same category#
datSplit2 <- datSplit#
datSplit <- datSplit2[as.character(1:10)]#
datSplit[['10']] <- do.call(rbind, datSplit2[which(names(datSplit2) == '10'):length(datSplit2)])#
names(datSplit)[10] <- '>10'#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1, length(datSplit)), ylim = yrange)#
	axis(1, at = c(0, 1:length(datSplit)), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, time-constant', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# multi-regime diversity-dependent#
dat2 <- dat[which(dat$setname %in% c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4')),]#
#
datSplit <- split(dat2, dat2$nRegimes)#
#
defaultYrange <- c(0, 0.2)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(1.5, 5.5), ylim = yrange)#
	axis(1, at = c(1, as.numeric(names(datSplit))), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in as.numeric(names(datSplit))) {#
		qStats <- quantile(datSplit[[as.character(j)]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('nRegimes', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'multi-regime, diversity-dependent', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
# Evolving Rates#
#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
#
dat2 <- dat[which(dat$setname == 'evolvingRates'),]#
dat2$sigma <- sapply(dat2$treeName, function(x) treeDat[which(treeDat$treeName == x), 'sigma'])#
table(dat2$sigma)#
#
datSplit <- split(dat2, dat2$sigma)#
#
defaultYrange <- c(0, 0.4)#
#
for (i in 1:5) {#
	tipMetric <- rateMetrics[i]#
	errorCol <- Reduce(intersect, list(grep(rateType, colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetric, colnames(dat))))#
	if (tipMetric != 'lambdaTB') {#
		yrange <- defaultYrange#
	} else {#
		yrange <- c(0, quantile(unlist(sapply(datSplit, function(x) x[, errorCol])), 0.975))#
	}#
	plot.new()#
	plot.window(xlim = c(0.5,3.5), ylim = yrange)#
	axis(1, at = c(-0.5, 1:3), labels = c(NA, names(datSplit)))#
	axis(2, at = c(-0.25, axTicks(2)))#
	for (j in 1:length(datSplit)) {#
		qStats <- quantile(datSplit[[j]][, errorCol], c(qrange[1], 0.25, 0.5, 0.75, qrange[2]), na.rm=TRUE)#
		rect(j - width/2, qStats[2], j + width/2, qStats[4], col=gray(0.75))#
		segments(j, qStats[1], j, qStats[2], lty=2, lend=1)#
		segments(j, qStats[4], j, qStats[5], lty=2, lend=1)#
		segments(j - width/3, qStats[1], j + width/3, qStats[1], lend=1)#
		segments(j - width/3, qStats[5], j + width/3, qStats[5], lend=1)#
		segments(j - width/3, qStats[3], j + width/3, qStats[3], lwd=2, lend=1)#
	}#
	abline(h=0, lty=3)#
	mtext('sigma', side = 1, cex=0.5, line = 2)#
	mtext('mean absolute error', side = 2, cex=0.5, line = 2)#
	title(main = rateMetrics[i], line = -0.5)#
	if (i == 3) {#
		title(main = 'evolving rates', line = 1.5, cex.main=1.5, xpd=NA)#
	}#
}#
dev.off()
# plot tip rate values against each other, no by-tree or by-regime summarizing#
#
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
table(dat$setname)
# bigger figure: all tip metrics, for both lambda and net div#
#
setlist <- list('multi-regime, time-constant'= c('fossilBAMM', 'highTurnoverBD', 'LambdaEqualsMu','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'multi-regime, diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')#
#
tipMetrics <- c('lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
titleLine <- c(-2, -28, -52, -79, -104, -128)
gridVal <- 20
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=20, units='in', res=300)#
par(mfrow=c(6,4))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
i<-2
j<-4
qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))
cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)
gridVal <- 500
cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.01, axTicks(1)))#
		axis(2, at = c(-0.01, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]
?heatscatterpoints
update.packages(ask=F)
# compare speciation rate and net diversification rate#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)
# keep only single regime trees#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
dat2 <- dat2[which(dat2$nRegimes == 1),]
# get true extinction rate for 1 regime trees#
tmp <- treeDat[which(treeDat$treeName %in% dat2$treeName),]#
epsVec <- setNames(tmp$mu0 / tmp$lambda0, tmp$treeName)#
epsVec <- epsVec[dat2$treeName]#
#
tipMetrics <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
j<-1
errorMetric <- c('PE1','PE3', 'absoluteError')[j]
par(mfrow=c(2,4), mar = c(4,4,2,2))
i<-3
i<-4
tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- c(-1, 8)#
		if (errorMetric == 'absoluteError') {#
			yrange <- c(-0.2, 0.4)#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = tipMetric, line = 0)
i
tipMetric <- tipMetricsNetDiv[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- c(-1, 8)#
		if (errorMetric == 'absoluteError') {#
			yrange <- c(-0.2, 0.4)#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)
plot(log(epsVec, dat2[, errorCol]))
# analyze proportional error in rates as a function of relative extinction#
# compare speciation rate and net diversification rate#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error of lambda and lambda - mu against eps#
# first for single regime trees#
# keep only single regime trees#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
dat2 <- dat2[which(dat2$nRegimes == 1),]#
#
# get true extinction rate for 1 regime trees#
tmp <- treeDat[which(treeDat$treeName %in% dat2$treeName),]#
epsVec <- setNames(tmp$mu0 / tmp$lambda0, tmp$treeName)#
epsVec <- epsVec[dat2$treeName]#
#
tipMetrics <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
j<-3
# analyze proportional error in rates as a function of relative extinction#
# compare speciation rate and net diversification rate#
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)#
treeDat <- read.csv('~/Dropbox/tipRatesProject/treeSummary.csv', stringsAsFactors=FALSE)#
# ---------------------------------------------------------#
# ---------------------------------------------------------#
## Proportional error of lambda and lambda - mu against eps#
# first for single regime trees#
# keep only single regime trees#
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]#
dat2 <- dat2[which(dat2$nRegimes == 1),]#
#
# get true extinction rate for 1 regime trees#
tmp <- treeDat[which(treeDat$treeName %in% dat2$treeName),]#
epsVec <- setNames(tmp$mu0 / tmp$lambda0, tmp$treeName)#
epsVec <- epsVec[dat2$treeName]#
#
tipMetrics <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB', 'lambdaND', 'lambdaDR', 'netDivBAMM')#
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute error')
errorMetric <- c('PE1','PE3', 'absoluteError')[j]
par(mfrow=c(2,4), mar = c(4,4,2,2))#
	for (i in 1:4) {#
		tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- c(-1, 8)#
		if (errorMetric == 'absoluteError') {#
			yrange <- c(-0.2, 0.4)#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = tipMetric, line = 0)#
		if (errorMetric %in% c('PE1','PE2', 'absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
# second row: net div#
	for (i in 1:4) {#
		tipMetric <- tipMetricsNetDiv[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- c(-1, 8)#
		if (errorMetric == 'absoluteError') {#
			yrange <- c(-0.2, 0.4)#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		if (tipMetric == 'netDivBAMM') {#
			title(main = 'BAMM net div.', line = 0)#
		}#
		if (errorMetric %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)
i<-1
tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(quantile(dat2[, errorCol], 1))#
		}
yrange
yrange <- c(0, quantile(dat2[, errorCol], 1))
yrange
par(mfrow=c(2,4), mar = c(4,4,2,2))#
	defaultYrange <- c(0, 0.3)#
	for (i in 1:4) {#
		tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 1))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = tipMetric, line = 0)#
		if (errorMetric %in% c('PE1','PE2', 'absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
#
	# second row: net div#
	for (i in 1:4) {#
		tipMetric <- tipMetricsNetDiv[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 1))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		if (tipMetric == 'netDivBAMM') {#
			title(main = 'BAMM net div.', line = 0)#
		}#
		if (errorMetric %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)
par(mfrow=c(2,4), mar = c(4,4,2,2))#
	defaultYrange <- c(0, 0.3)#
	for (i in 1:4) {#
		tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 0.95))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = tipMetric, line = 0)#
		if (errorMetric %in% c('PE1','PE2', 'absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
#
	# second row: net div#
	for (i in 1:4) {#
		tipMetric <- tipMetricsNetDiv[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 0.95))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		if (tipMetric == 'netDivBAMM') {#
			title(main = 'BAMM net div.', line = 0)#
		}#
		if (errorMetric %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)
pdf(paste0('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossEpsilon_lambdaAndNetDiv_', errorMetric, '.pdf'), width=10, height=5)#
	par(mfrow=c(2,4), mar = c(4,4,2,2))#
	defaultYrange <- c(0, 0.3)#
	for (i in 1:4) {#
		tipMetric <- tipMetrics[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 0.95))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = tipMetric, line = 0)#
		if (errorMetric %in% c('PE1','PE2', 'absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
#
	# second row: net div#
	for (i in 1:4) {#
		tipMetric <- tipMetricsNetDiv[i]#
		errorLabel <- errorMetricNames[errorMetric]#
		errorCol <- Reduce(intersect, list(grep('tipNetDiv', colnames(dat)), grep(tipMetric, colnames(dat)), grep(errorMetric, colnames(dat))))#
		plot.new()#
		yrange <- defaultYrange#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[, errorCol], 0.95))#
		}#
		plot.window(xlim = c(0,1), ylim = yrange)#
		axis(1)#
		axis(2)#
		points(epsVec, dat2[, errorCol], cex=0.3)#
		mtext('epsilon', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		if (tipMetric == 'netDivBAMM') {#
			title(main = 'BAMM net div.', line = 0)#
		}#
		if (errorMetric %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetric %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	mtext('lambda', side=2, outer=TRUE, adj=0.85, line = -1)#
	mtext('lambda - mu', side=2, outer=TRUE, adj=0.18, line = -1)#
	dev.off()
dat <- read.csv('~/Dropbox/tipRatesProject/rateErrorMetrics.csv', stringsAsFactors=FALSE)
dat2 <- dat[which(dat$setname %in% c('MooreEtAl2016','RaboskyEtAl2017','fossilBAMM','MeyerWiens2017','highTurnoverBD', 'LambdaEqualsMu')),]
errorMetricOptions <- c('PE1','PE2','PE3','r2','slope', 'absoluteError')
rateMetrics <- c('CRBDlambda', 'lambdaTB', 'lambdaND', 'lambdaDR', 'lambdaBAMM')
errorMetricNames <- c(PE1='Prop. Error 1', PE2='Prop. Error 2', PE3='Prop. Error 3', PE4='Prop. 4', r2='OLS R2', slope='OLS slope', absoluteError='mean absolute')
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-50, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
j<-1
errorLabel <- errorMetricNames[errorMetricOptions[j]]
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))
i<-1
rateMetrics
tipMetric <- rateMetrics[i]
errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))
plot(log10(dat2$nTips), dat2[,errorCol])
plot(log10(dat2$nTips), dat2[,errorCol], ylim=c(0,50))
plot(log10(dat2$nTips), dat2[,errorCol], ylim=c(-10,30))
for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- quantile(dat2[,errorCol], c(0.025, 0.975), na.rm=T)#
		#yrange <- yranges[[errorMetricOptions[j]]]#
		if (!is.finite(yrange[2])) {#
			yrange[2] <- quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T)#
		}#
		if (j == 5) yrange <- c(0,1)#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = log10(c(10, 100, 1000, 10000)), labels =  c(10, 100, 1000, 10000))#
		axis(2)#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
rateMetrics
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- quantile(dat2[,errorCol], c(0.025, 0.975), na.rm=T)#
		#yrange <- yranges[[errorMetricOptions[j]]]#
		if (!is.finite(yrange[2])) {#
			yrange[2] <- quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T)#
		}#
		if (j == 5) yrange <- c(0,1)#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = log10(c(10, 100, 1000, 10000)), labels =  c(10, 100, 1000, 10000))#
		axis(2)#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
i<-1
tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]
yrange
tipMetric == 'lambdaTB'
tipMetric
i<-2
tipMetric <- rateMetrics[i]
errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))
yrange <- yranges[[errorMetricOptions[j]]]
tipMetric == 'lambdaTB'
quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T)
quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], c(0.05,0.95), na.rm=T)
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = log10(c(10, 100, 1000, 10000)), labels =  c(10, 100, 1000, 10000))#
		axis(2)#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2)#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(-1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
j
j<-2
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(-1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yrange
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-100, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(-1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yrange
yrange[2] * 0.1
yrange[1] * 0.1
yrange[1] * 1.1
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.1, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
errorLabel
errorLabel <- errorMetricNames[errorMetricOptions[j]]
errorLabel
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-150, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-200, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-400, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(-0.2, 0.1))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
j
j<-3
errorLabel <- errorMetricNames[errorMetricOptions[j]]
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c(yrange[1] * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
j
j<-4
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
j
j<-5
errorLabel <- errorMetricNames[errorMetricOptions[j]]
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
errorLabel
errorMetricOptions <- c('PE1','PE2','PE3','absoluteError')
errorMetricOptions
j
j<-4
errorLabel <- errorMetricNames[errorMetricOptions[j]]
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-400, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(0, 1))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
yranges <- list(#
	PE1 = c(-1, 2), #
	PE2 = c(-400, 400), #
	PE3 = c(0, 2.5), #
	PE4 = c(-1, 50), #
	r2 = c(0, 1.1),#
	slope = c(-1, 2),#
	absoluteError = c(0, 0.5))
par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}
for (j in 1:length(errorMetricOptions)) {#
	errorLabel <- errorMetricNames[errorMetricOptions[j]]#
	pdf(paste0('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossTreeSize_', errorMetricOptions[j], '.pdf'), width=10, height=3)#
	par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	dev.off()#
}
for (j in 1:length(errorMetricOptions)) {#
	errorLabel <- errorMetricNames[errorMetricOptions[j]]#
	pdf(paste0('~/Dropbox/tipRatesProject/preliminaryplots/errorAcrossTreeSize_', errorMetricOptions[j], '.pdf'), width=10, height=2)#
	par(mfrow=c(1,5), mar = c(3,3,1,1), oma = c(0,2,0,0))#
	for (i in 1:5) {#
		tipMetric <- rateMetrics[i]#
		errorCol <- Reduce(intersect, list(grep('tipLambda', colnames(dat)), grep(rateMetrics[i], colnames(dat)), grep(errorMetricOptions[j], colnames(dat))))#
		yrange <- yranges[[errorMetricOptions[j]]]#
		if (tipMetric == 'lambdaTB') {#
			yrange <- c(0, quantile(dat2[which(is.finite(dat2[, errorCol])),errorCol], 0.95, na.rm=T))#
		}#
		plot.new()#
		plot.window(xlim = range(log10(c(10,10000))), ylim = yrange)#
		axis(1, at = c(0, log10(c(10, 100, 1000, 10000))), labels =  c(NA, 10, 100, 1000, 10000))#
		axis(2, at = c((yrange[1] - 1) * 1.5, axTicks(2)))#
		points(log10(dat2$nTips), dat2[,errorCol], cex=0.25)#
		mtext('log10 tree size', side = 1, cex=0.5, line = 2)#
		mtext(errorLabel, side = 2, cex=0.5, line = 2)#
		title(main = rateMetrics[i], line = -0.5)#
		if (errorMetricOptions[j] %in% c('PE1','PE2','absoluteError')) {#
			abline(h=0, lty=3)#
		} else if (errorMetricOptions[j] %in% c('PE3','PE4')) {	#
			abline(h=1, lty=3)#
		}#
	}#
	dev.off()#
}
require(ppcor)#
require(AICcmodavg)#
#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)#
#
#regimeSummary <- read.csv('regimeSummary.csv', stringsAsFactors=FALSE)#
#
summary(lm(lambdaDR ~ tipLambda, data = regimeSummary))#
summary(lm(lambdaDR ~ tipNetDiv, data = regimeSummary))#
summary(lm(lambdaDR ~ tipLambda + tipNetDiv, data = regimeSummary))#
#
# semi-partial correlations#
spcor(regimeSummary[,c('lambdaDR','tipLambda','tipNetDiv')])$estimate#
spcor(regimeSummary[,c('lambdaDR','tipLambda','tipNetDiv')])$p.value
fit1 <- lm(lambdaDR ~ tipLambda, data = regimeSummary)#
fit2 <- lm(lambdaDR ~ tipNetDiv, data = regimeSummary)#
#
aictab(list(lambda=fit1, netdiv=fit2))
require(LSD)#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
dat <- do.call(rbind, allRatesList)#
#
table(dat$setname)#
#
# # MitchellRabosky2016: single-regime birth-death
setlist <- list('multi-regime, time-constant'= c('fossilBAMM', 'highTurnoverBD', 'LambdaEqualsMu','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017'), 'multi-regime, diversity-dependent'=c('Rabosky2014_DD_k1', 'Rabosky2014_DD_k2', 'Rabosky2014_DD_k3', 'Rabosky2014_DD_k4'), 'evolving rates'='evolvingRates')#
#
tipMetrics <- c('lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
titleLine <- c(-2, -28, -52, -79, -104, -128)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=20, units='in', res=300)#
par(mfrow=c(6,4))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()#
# # # By dataset#
# setlist <-c('fossilBAMM','highTurnoverBD','LambdaEqualsMu','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017')#
#
# png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=6, height=20, units='in', res=300)#
# par(mfrow=c(6,2))#
#
# for (i in 1:length(setlist)) {#
	# qq <- dat[which(dat$setname %in% setlist[[i]]),]#
#
	# for (j in 3:length(tipMetrics)) {#
		# plot.new()#
		# plot.window(xlim = c(0, 0.6), ylim = c(0, 0.6))#
		# axis(1)#
		# axis(2)#
		# mtext('true lambda', side=1, line = 2.5)#
		# mtext(tipMetrics[j], side=2, line = 2.5)#
		# heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		# abline(a=0, b=1, lty=3)#
		# title(main = setlist[i])#
	# }#
# }#
# dev.off()
tipMetrics <- c('lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
tipMetricsNetDiv <- c('lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
titleLine <- c(-2, -25, -52, -79, -104, -128)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(c(0,0.65), c(0, 0.65), lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(0, 0, 0.65, 0.65, lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()#
# # # By dataset#
# setlist <-c('fossilBAMM','highTurnoverBD','LambdaEqualsMu','MeyerWiens2017','MooreEtAl2016','RaboskyEtAl2017')#
#
# png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRates_byDataSet.png', width=6, height=20, units='in', res=300)#
# par(mfrow=c(6,2))#
#
# for (i in 1:length(setlist)) {#
	# qq <- dat[which(dat$setname %in% setlist[[i]]),]#
#
	# for (j in 3:length(tipMetrics)) {#
		# plot.new()#
		# plot.window(xlim = c(0, 0.6), ylim = c(0, 0.6))#
		# axis(1)#
		# axis(2)#
		# mtext('true lambda', side=1, line = 2.5)#
		# mtext(tipMetrics[j], side=2, line = 2.5)#
		# heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		# abline(a=0, b=1, lty=3)#
		# title(main = setlist[i])#
	# }#
# }#
# dev.off()
titleLine <- c(-2, -27, -52, -79, -104, -128)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(0, 0, axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
titleLine <- c(-2, -26, -48, -74, -100, -120)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(0, 0, axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i])#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		abline(a=0, b=1, lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3])#
}#
dev.off()
?mtet
?mtext
?par
titleLine <- c(-2, -26, -48, -71, -97, -16)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i], font=2)#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3], font=2)#
}#
dev.off()
titleLine <- c(-2, -26, -48, -71, -95, -116)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i], font=2)#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3], font=2)#
}#
dev.off()
titleLine <- c(-2, -26, -48, -71, -94, -116)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i], font=2)#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.9, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3], font=2)#
}#
dev.off()
titleLine <- c(-2, -26, -48, -71, -94, -116)#
#
gridVal <- 1000#
png('~/Dropbox/tipRatesProject/preliminaryplots/trueVSestimatedTipRatesBig.png', width=10, height=18, units='in', res=300)#
par(mfrow=c(6,4), mar = c(4,4,3,1))#
#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true lambda', side=1, line = 2.5)#
		mtext(tipMetrics[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipLambda, qq[, tipMetrics[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipLambda, qq[, tipMetrics[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.95, cex=0.7)#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i], font=2)#
}#
for (i in 1:length(setlist)) {#
	qq <- dat[which(dat$setname %in% setlist[[i]]),]#
	axisRange <- quantile(qq$tipLambda, c(0, 0.95))#
#
	for (j in 1:length(tipMetrics)) {#
		cat(i, '--', j, '\n')#
		plot.new()#
		plot.window(xlim = axisRange, ylim = axisRange)#
		axis(1, at = c(-0.1, axTicks(1)))#
		axis(2, at = c(-0.1, axTicks(2)))#
		mtext('true net div.', side=1, line = 2.5)#
		mtext(tipMetricsNetDiv[j], side=2, line = 2.5)#
		#heatscatterpoints(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], grid= gridVal)#
		segments(axisRange[1], axisRange[1], axisRange[2], axisRange[2], lty=3)#
		r <- cor.test(qq$tipNetDiv, qq[, tipMetricsNetDiv[j]], method='spearman')$estimate[[1]]#
		mtext(paste('r = ', round(r,2)), side=1, line = -2, adj = 0.95, cex=0.7)#
#
	}#
	mtext(names(setlist)[i], side = 3, outer=TRUE, line = titleLine[i+3], font=2)#
}#
dev.off()
require(LSD)#
#
regimeSummary <- read.csv('~/Dropbox/tipRatesProject/regimeSummary.csv', stringsAsFactors=FALSE)#
#
regimeSummary[, 'CRBDnetdiv'] <- regimeSummary$CRBDlambda - regimeSummary$CRBDmu
# Speciation rate, Pearson correlation#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
metricColors <- c('black','dark green','dark orange','red','blue')#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByRegimeSize_compact.pdf', width=8, height=8)#
#
par(mfrow=c(2,2), mar = c(4,5,2,1))#
#
# speciation rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.2, cex=1)#
title(main = 'speciation rate')#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
#
#legend(40, 0.8, legend = c(expression(paste(lambda['CRBD'])),expression(paste(lambda['TB'])), expression(paste(lambda['ND'])), expression(paste(lambda['DR'])),expression(paste(lambda['BAMM']))), col = metricColors, lwd=2, bty='n', xpd=NA)#
#
legend(40, 0.8, legend = c('CRBD','TB','ND','DR','BAMM'), col = metricColors, lwd=2, bty='n', xpd=NA)#
#
# net div rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.2, cex=1)#
title(main = 'net div. rate')#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
# speciation rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.75))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('OLS slope', side = 2, line = 2.2, cex=1)#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
# net div rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.75))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('OLS slope', side = 2, line = 2.2, cex=1)#
#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
#
dev.off()
maxRegimeCount <- 50#
#
allRatesList <- readRDS('~/Dropbox/tipRatesProject/allRatesList.rds')#
regimeSize <- sort(unique(regimeSummary$nTips))#
#
regimeSize <- 1:maxRegimeCount#
#
rateMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
rateMetricsNetDiv <- c('CRBDnetdiv','lambdaTB','lambdaND','lambdaDR','netDivBAMM')#
regimeSizeTable <- as.data.frame(matrix(nrow = length(regimeSize), ncol = 21))#
colnames(regimeSizeTable) <- c('regimeSize', paste0(rateMetrics, 'lambda_cor'), paste0(rateMetrics, 'lambda_slope'), paste0(rateMetricsNetDiv, 'netdiv_cor'), paste0(rateMetricsNetDiv, 'netdiv_slope'))#
regimeSizeTable$regimeSize <- regimeSize#
#
for (i in 1:length(regimeSize)) {#
	xx <- regimeSummary[which(regimeSummary$nTips >= regimeSize[i]),]#
	# speciation rate#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_cor')] <- cor(xx$tipLambda, xx[, rateMetrics[j]])#
			regimeSizeTable[i, paste0(rateMetrics[j], 'lambda_slope')] <- summary(lm(xx[, rateMetrics[j]] ~ xx$tipLambda))$coef[2,1]#
		}#
	}#
	# net diversification#
	if (nrow(xx) > 1) {#
		for (j in 1:length(rateMetrics)) {#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_cor')] <- cor(xx$tipNetDiv, xx[, rateMetricsNetDiv[j]])#
			regimeSizeTable[i,paste0(rateMetricsNetDiv[j], 'netdiv_slope')] <- summary(lm(xx[, rateMetricsNetDiv[j]] ~ xx$tipNetDiv))$coef[2,1]#
		}#
	}#
}#
#
metricLabels <- c('CRBD','TB','ND','DR','BAMM')
# Speciation rate, Pearson correlation#
tipMetrics <- c('CRBDlambda','lambdaTB','lambdaND','lambdaDR','lambdaBAMM')#
#
metricColors <- c('black','dark green','dark orange','red','blue')#
#
pdf('~/Dropbox/tipRatesProject/preliminaryplots/meanTipRatesByRegimeSize_compact.pdf', width=8, height=8)#
#
par(mfrow=c(2,2), mar = c(4,5,2,1))#
#
# speciation rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.2, cex=1)#
title(main = 'speciation rate')#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
#
#legend(40, 0.8, legend = c(expression(paste(lambda['CRBD'])),expression(paste(lambda['TB'])), expression(paste(lambda['ND'])), expression(paste(lambda['DR'])),expression(paste(lambda['BAMM']))), col = metricColors, lwd=2, bty='n', xpd=NA)#
#
legend(40, 0.8, legend = c('CRBD','TB','ND','DR','BAMM'), col = metricColors, lwd=2, bty='n', xpd=NA)#
#
# net div rate, correlation#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('Pearson correlation', side = 2, line = 2.2, cex=1)#
title(main = 'net div. rate')#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_cor')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
# speciation rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.75))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('OLS slope', side = 2, line = 2.2, cex=1)#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetrics[i], 'lambda_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
# net div rate, slope#
plot.new()#
plot.window(xlim = range(regimeSize), ylim = c(0,1.75))#
axis(1, at = c(-1, axTicks(1)))#
axis(2, at = c(-1, axTicks(2)))#
mtext('minimum regime size', side = 1, line = 2.2, cex=1)#
mtext('OLS slope', side = 2, line = 2.2, cex=1)#
#
for (i in 1:length(rateMetrics)) {#
	lines(regimeSize, regimeSizeTable[, paste0(rateMetricsNetDiv[i], 'netdiv_slope')], col= metricColors[i], lwd=2)#
}#
abline(h=1, lty=3)#
#
dev.off()
# Get BAMM convergence statistics#
#
# We will calculate effective sample size and Geweke z score for the log likelihood and for the number of shifts, with a 50% burnin.#
#
require(coda)#
source('~/Dropbox/tipRatesProject/sourceFxns.R')#
#
path <- '~/Dropbox/tipRatesProject/trees/'#
#
# set names that were run with BAMM#
setnames <- c('highTurnoverBD', 'LambdaEqualsMu', 'evolvingRates', 'MeyerWiens2017')
summaryTable <- as.data.frame(matrix(nrow = 0, ncol = 5))#
colnames(summaryTable) <- c('treeName', 'loglik_effectiveSize', 'nShifts_effectiveSize', 'loglik_geweke', 'nShifts_geweke')
summaryTable <- as.data.frame(matrix(nrow = 0, ncol = 5))#
colnames(summaryTable) <- c('treeName', 'loglik_effectiveSize', 'nShifts_effectiveSize', 'loglik_geweke', 'nShifts_geweke')#
#
for (i in 1:length(setnames)) {#
	folders <- list.files(path, pattern = setnames[i])#
	folders <- folders[order(as.numeric(gsub(paste0(setnames[i], '_'), '', folders)))]#
	setTable <- as.data.frame(matrix(nrow = length(folders), ncol = 5))#
	colnames(setTable) <- colnames(summaryTable)#
	setTable$treeName <- folders#
	for (j in 1:length(folders)) {#
		setwd(paste0(path, folders[j]))#
		setTable[j, 2:5] <- checkBAMMconvergence()#
	}#
	summaryTable <- rbind.data.frame(summaryTable, setTable)#
}
head(summaryTable)
nrow(summaryTable)
table(summaryTable[,2] < 200)
table(summaryTable[,3] < 200)
table(summaryTable[,4] < -2 | summaryTable[,4] > 2)
62/1420
30/1420
114/1420
write.csv(summaryTable, '~/Dropbox/tipRatesProject/bammConvergenceStats.csv', row.names=FALSE)
